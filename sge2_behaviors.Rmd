---
title: "sge2_behaviors"
output: html_document
date: '2022-09-29'
---

```{r setup, include=FALSE}
library(ggplot2)
library(limma)
library(edgeR)
library(ggrepel)
library(preprocessCore)
library(reshape2)
library(EMMREML)
library(tidyverse)
library(data.table)
library(cobs)
library(qvalue)
library(viridis)
library(mashr)
library(cowplot)
library(UpSetR)
library(parallel)
library(grid)
library(EloRating)

workDir <- "~/Dropbox (Personal)/macaque/vaccine/"
dataDir <- paste0(workDir,"data/")
modelFolder <- paste0(workDir,"models/")
outDir <- paste0(workDir,"output/")
figDir <- paste0(workDir,"figures/")

sampleDates <- read.table("~/Dropbox (Personal)/macaque/sge_behavior/samplingDatesForR.csv", sep = ",", header = T)
sampleDatesP2 <- read.table(paste0("~/Dropbox (Personal)/macaque/sge_behavior/data/eventDatesPhase2.csv"), sep = ",", header = T)
sampleDatesP2$group <- gsub(pattern = "NO", replacement = "", sampleDatesP2$group)
```


Pull in observation data from noah simons' github
```{r}
## read in necessary functions
#load('/Users/noah/Desktop/behavior_functions.RData')
load(url("https://github.com/ndsimons/sge.II.obs.analysis/blob/master/functions/behavior_functions.RData?raw=true"))

## load individual metadata
#intro_all <- read.delim('/Users/noah/Desktop/intro_all_v3.txt')
intro_all <- "https://github.com/ndsimons/sge.II.obs.analysis/raw/master/obs.data/intro_all_v3.txt"
intro_all <- read.delim(intro_all)
intro_all$ID <- gsub('77_06', 'mo', intro_all$ID)
intro_all$ID <- gsub('Dj7', 'D2', intro_all$ID)

## read in obs files ( '_1' denotes phase I groups, no underscore are phase II groups); all obs files for a group are concatenated and retain headers
#load('/Users/noah/Desktop/all.obs.files.RData')
load(url("https://github.com/ndsimons/sge.II.obs.analysis/blob/master/obs.data/all.obs.files.RData?raw=true"))
SPF5_1$behavior <- gsub('e2', 'et', SPF5_1$behavior)
NSPF4$behavior <- gsub('dj', 'd2', NSPF4$behavior)

## add # of obs per individual to intros_all
data_list <- list(NSPF1 = NSPF1,
                  NSPF2 = NSPF2,
                  NSPF3 = NSPF3,
                  NSPF4 = NSPF4,
                  NSPF5 = NSPF5,
                  SPF1 = SPF1,
                  SPF2 = SPF2,
                  SPF3 = SPF3,
                  SPF4 = SPF4,
                  SPF5 = SPF5,
                  NSPF1_1 = NSPF1_1,
                  NSPF2_1 = NSPF2_1,
                  NSPF3_1 = NSPF3_1,
                  NSPF4_1 = NSPF4_1,
                  NSPF5_1 = NSPF5_1,
                  SPF1_1 = SPF1_1,
                  SPF2_1 = SPF2_1,
                  SPF3_1 = SPF3_1,
                  SPF4_1 = SPF4_1,
                  SPF5_1 = SPF5_1)
```

```{r}

#re-implemented the sub codes, moved them to if/else
convert.dom.gitWsub <- function(x) {
x<-cbind(x[,c(1,2)],matrix(nrow=nrow(x),ncol=3))
date=0
for (r in 1:nrow(x)) {
	if (substr(x[r,1],1,5)=="HDATE") date=substr(x[r,1],7,20)
	else if (substr(x[r,1],1,5)!="HDATE") {
	b<-substr(x[r,1],3,4)
	if (b%in%c("tn","tc","at","ch")&!substr(x[r,1],1,2)%in%c("fz","cn","47")&!substr(x[r,1],5,6)%in%c("fz","cn","47")) {x[r,3]<-substr(x[r,1],1,2); x[r,4]<-substr(x[r,1],5,6)} else if (b%in%c("gr","wd")&!substr(x[r,1],1,2)%in%c("fz","cn","47")&!substr(x[r,1],5,6)%in%c("fz","cn","47")) {x[r,4]<-substr(x[r,1],1,2); x[r,3]<-substr(x[r,1],5,6)}
	x[r,5]<-date
	}
}
x<-(x[-which(is.na(x[,2])),])
x<-(x[-which(is.na(x[,3])),])
rownames(x)<-NULL
x<-x[,c(2:5)]
colnames(x)<-c("Time","Winner","Loser","Date")
x<-x[,c(4,1:3)]
x[,1]<-as.Date(x[,1],"%m/%d/%Y")
return(x)
}

### convert.dom.git - code that matches Noah's Elo code, but works on the github behavior data

convert.dom.git <- function(x) {
x<-cbind(x[,c(1,2)],matrix(nrow=nrow(x),ncol=3))
date=0
for (r in 1:nrow(x)) {
	if (substr(x[r,1],1,5)=="HDATE") date=substr(x[r,1],7,20)
	else if (substr(x[r,1],1,5)!="HDATE") {
	b<-substr(x[r,1],3,4)
	if (b%in%c("tn","tc","at","ch")) {x[r,3]<-substr(x[r,1],1,2); x[r,4]<-substr(x[r,1],5,6)} else if (b%in%c("gr","wd")) {x[r,4]<-substr(x[r,1],1,2); x[r,3]<-substr(x[r,1],5,6)}
	x[r,5]<-date
	}
}
x<-(x[-which(is.na(x[,2])),])
x<-(x[-which(is.na(x[,3])),])
rownames(x)<-NULL
x<-x[,c(2:5)]
colnames(x)<-c("Time","Winner","Loser","Date")
x<-x[,c(4,1:3)]
x[,1]<-as.Date(x[,1],"%m/%d/%Y")
return(x)
}
```

sge.behavioralRateData.df.readme

Column descriptions for files sge.I.behavioralRateData.df and sge.II.behavioralRateData.df

ID = Individual ID
group = Individual group
phase = Phase
elo = final elo - using all available behavioral data (this column is in sge.I.behavioralRateData.df only)
groom.min = number of minutes spent in grooming
agg.received.count = number of aggressive events received
agg.given.count = number of aggressive events given
no.obs = total number of 30 min observation periods
raw.groom.rate = grooming minutes per hour; (groom.min/no.obs)*2
raw.aggRec.rate = aggression events received per hour; (agg.received.count/no.obs)*2
raw.aggGiven.rate = aggression events given per hour; (agg.given.count/no.obs)*2
group.centered.groom.rate = within-group centered grooming rate; for each group: scale(raw.groom.rate, scale = F, center = T)
group.centered.aggRec.rate = within-group centered agg received rate; for each group: scale(raw.aggRec.rate, scale = F, center = T)
group.centered.aggGiven.rate = within-group centered agg given rate; for each group: scale(raw.aggGiven.rate, scale = F, center = T)
group.centered.scaled.groom.rate = within-group centered and scaled grooming rate; for each group: scale(raw.groom.rate, scale = T, center = T)
group.centered.scaled.aggRec.rate = within-group centered and scaled agg received rate; for each group: scale(raw.aggRec.rate, scale = T, center = T)
group.centered.scaled.aggGiven.rate = within-group centered and scaled agg given rate; for each group: scale(raw.aggGiven.rate, scale = T, center = T)
centered.groom.rate = centered grooming rate; scale(raw.groom.rate, scale = F)
centered.aggRec.rate = centered agg received rate; scale(raw.aggRec.rate, scale = F)
centered.aggGiven.rate = centered agg given rate; scale(raw.aggGiven.rate, scale = F)
centered.scaled.groom.rate = centered and scaled grooming rate; scale(raw.groom.rate, scale = T, center = T)
centered.scaled.aggRec.rate = centered and scaled agg received rate; scale(raw.aggRec.rate, scale = T, center = T)
centered.scaled.aggGiven.rate = centered and scaled agg given rate; scale(raw.aggGiven.rate, scale = T, center = T)


```{r calculated behavioral data from raw}
### grooming, agonisms received, & elo

### add an "end date" to the code

adjustData <- TRUE ### section in the code exists to drop data by date, but i haven't implemented that here
samplingDate <- "SingleCell" #or Vax or EnvChall
sgePhase <- 1

dataCombos <- cbind.data.frame(c(FALSE,FALSE,TRUE,TRUE,TRUE),
                               c(1,2,1,1,1),
                               c("","","SingleCell","Vax","EnvChall"))

colnames(dataCombos) <- c("adjustData","sgePhase","samplingDate")

r <- 1

for (r in 1:dim(dataCombos)[1]) {
  
  adjustData <- dataCombos$adjustData[r]
  samplingDate <- dataCombos$samplingDate[r]
  sgePhase <- dataCombos$sgePhase[r]
  
  dateDF <- sampleDates[colnames(sampleDates) %in% c("animal","group",paste0("date",samplingDate))]
  
  #add two letter code to dateDF
  #replace moonlight, drop leading "R", swap for uppers
  dateDF$twoLetter <- gsub('77_06', 'mo', dateDF$animal)
  dateDF$twoLetter <- gsub('^R', '', dateDF$twoLetter)
  dateDF$twoLetter <- toupper(substr(dateDF$twoLetter, start = 1, stop = 2))
  
  dateDF$group_1 <- paste0(dateDF$group,"_1")
  
  sgePhase <- 1
  massCalcElo <- FALSE
  
  if (sgePhase == 1) {
    phase_data <- data_list[names(data_list) %in% 
                              c("NSPF1_1","NSPF2_1","NSPF3_1","NSPF4_1","NSPF5_1",
                                "SPF1_1","SPF2_1","SPF3_1","SPF4_1","SPF5_1")]
    intro_phase <- subset(intro_all, phase == "SGE1")
  } else {
    phase_data <- data_list[names(data_list) %in% 
                              c("NSPF1","NSPF2","NSPF3","NSPF4","NSPF5",
                                "SPF1","SPF2","SPF3","SPF4","SPF5")]
    intro_phase <- subset(intro_all, phase == "SGE2")
  }

  social <- lapply(phase_data,convert.soc)
  dominance <- lapply(phase_data,convert.dom.git)
  
  ### This code allows for the dates to be modified, leaving out for now (10 Oct 2022)
  
  if ( adjustData == TRUE & sgePhase == 1 ) {
    
    dateDF$fracKept <- 0
    g <- names(dominance)[2]
    
    for (g in names(dominance)) {
      #g <- groupInfo$groupID[i]
      d <- sort(unique(subset(dateDF, group_1 == g)[,3]))[1]
      
      #which(names(social) == g)
      fractionKept <- mean(social[which(names(social) == g)][[1]]$Date < d)
      dataToKeep <- social[which(names(social) == g)][[1]]$Date < d
      domToKeep <- dominance[which(names(dominance) == g)][[1]]$Date < d
      
      dateDF$fracKept[which(dateDF$group_1 == g)] <- fractionKept
      
      social[which(names(social) == g)][[1]] <- social[which(names(social) == g)][[1]][dataToKeep,]
      dominance[which(names(dominance) == g)][[1]] <- dominance[which(names(dominance) == g)][[1]][domToKeep,]
      ### need to add dominance here too, edit the dominance data for Elo, social goes for agRec& groom
    }
  }

  groom <- lapply(social,function(x){x[which(x[,5]%in%c("GM","G-","ZZ")),]})
  aggs <- prox <- lapply(social,function(x){x[which(x[,5]%in%c("TN","TC","AT","CH")),]})
  #aggs.contact <- lapply(social,function(x){x[which(x[,5]%in%c("TC","AT")),]})
  #aggs.nocontact <- lapply(social,function(x){x[which(x[,5]%in%c("TN","CH")),]})
  agg.received <- lapply(aggs,function(x){aggregate(x[,4],by=list(x[,4]),length)})
  #agg.given <- lapply(aggs,function(x){aggregate(x[,3],by=list(x[,3]),length)})
  #agg.nocontact.received <- lapply(aggs.nocontact,function(x){aggregate(x[,4],by=list(x[,4]),length)})
  #agg.nocontact.given <- lapply(aggs.nocontact,function(x){aggregate(x[,3],by=list(x[,3]),length)})
  #agg.contact.received <- lapply(aggs.contact,function(x){aggregate(x[,4],by=list(x[,4]),length)})
  #agg.contact.given <- lapply(aggs.contact,function(x){aggregate(x[,3],by=list(x[,3]),length)})
  
  ### what is this doing... -- recounting the number of observations
  
  if ( adjustData == TRUE & sgePhase == 1 ) {
    dateDF$numObs <- 0
    dateDF <- dateDF[order(dateDF$group),]
    
    for (g in names(dominance)) {
      #g <- groupInfo$groupID[i]
      gIDs <- which(dateDF$group_1 == g)
      
      newObs <- length(unique(social[[which(names(social) == g)]]$Date))
      
      dateDF$numObs[gIDs] <- newObs
    }
    
  } else {
    dateDF <- dateDF[order(dateDF$group),]
  }

  group <- vector()
  ID1 <- vector()
  ID2 <- vector()
  count <- 1

  for (i in unique(intro_phase$group)) {
    id1 <- unique(subset(intro_phase, group == i)$ID)
    for (j in id1){
      for (k in id1){
        if (j != k){
          ID1[count] <- j
          ID2[count] <- k
          group[count] <- i
          count <- count + 1
        }
      }
    }
  }
  
  ## calculate grooming
  groom.tot<-data.frame(matrix(ncol=17,nrow=length(ID1)))
  groom.tot$X1 <- ID1
  groom.tot$X2 <- ID2
  groom.tot$X3 <- group
  colnames(groom.tot) <- c("ID1","ID2","group","no.obs","bouts","ID1.groom",
                           "ID2.groom","min","ID1.groom.min","ID2.groom.min",
                           "ID1.rank","ID2.rank","ID1.ord.rank","ID2.ord.rank",
                           "agg.bouts","ID1.agg","ID2.agg")
  
  # change IDs to short, uppercase IDs
  groom.tot[,1] <- as.character(groom.tot[,1]); 
  groom.tot[,2] <- as.character(groom.tot[,2]); 
  groom.tot[,3] <- as.character(groom.tot[,3])
  groom.tot$ID1 <- toupper(substr(groom.tot$ID1, 1,2))
  groom.tot$ID2 <- toupper(substr(groom.tot$ID2, 1,2))
  groom.tot$ID1 <- gsub('77','MO',groom.tot$ID1)
  groom.tot$ID2 <- gsub('77','MO',groom.tot$ID2)
  intro_phase$ID <- toupper((substr(intro_phase$ID, 1,2)))
  
  ##caclulate grooming bouts
  for (id in 1:nrow(groom.tot)){
    id1 <- groom.tot[id,"ID1"]; id2<-groom.tot[id,"ID2"]; 
    g <- groom[[as.character(groom.tot[id,"group"])]]; 
    b1=0;b2=0;grp<-groom.tot[id,"group"]
    b1=sum(g[,5]=="GM"&g[,3]==id1 & g[,4]==id2)
    b2=sum(g[,5]=="GM"&g[,4]==id1 & g[,3]==id2)
    groom.tot[id,5]=b1+b2;groom.tot[id,6]=b1;groom.tot[id,7]=b2
    groom.tot[id,4]=intro_phase[which(intro_phase[,"ID"]==id1&intro_phase$group==grp),"num.obs"]
    groom.tot[id,"ID1.rank"]=intro_phase[which(intro_phase[,"ID"]==id1&intro_phase$group==grp),"elo"]
    groom.tot[id,"ID2.rank"]=intro_phase[which(intro_phase[,"ID"]==id2&intro_phase$group==grp),"elo"]
    groom.tot[id,"ID1.ord.rank"]=intro_phase[which(intro_phase[,"ID"]==id1&intro_phase$group==grp),"ordinal.rank"]
    groom.tot[id,"ID2.ord.rank"]=intro_phase[which(intro_phase[,"ID"]==id2&intro_phase$group==grp),"ordinal.rank"]
  }  
  
  ## calculate grooming times
  groom.tot$ID1.groom.min <- NA
  groom.tot$ID2.groom.min <- NA
  groom.tot$min <- NA
  
  for (i in 1:nrow(groom.tot)){
    id1 <- groom.tot[i,"ID1"]
    id2 <- groom.tot[i,"ID2"]
    t1=0
    t2=0
    g <- groom[[as.character(groom.tot[i,"group"])]]
    if (id1%in%c(g[,3],g[,4])&id2%in%c(g[,3],g[,4])){
      g<-g[which((g[,4]==id1 & g[,3]==id2 )|(g[,3]==id1 & g[,4]==id2)|g[,3]=="ZZ"),]
      for (r in 1:nrow(g)){
        if (g[r,5]=="GM" & g[r,3]==id1 & g[r,4]==id2) t1=t1+(g[r+1,2]-g[r,2])
        if (g[r,5]=="GM" & g[r,4]==id1 & g[r,3]==id2) t2=t2+(g[r+1,2]-g[r,2])
      }
      groom.tot[i,"ID1.groom.min"]=t1
      groom.tot[i,"ID2.groom.min"]=t2
      groom.tot[i,"min"]=t1+t2}
  }
  rm(t1);rm(t2);rm(i);rm(id1);rm(id2);rm(r);rm(g)
  
  # add phase info
  groom.tot$phase <- sgePhase
  
  tmp.minutes <- vector()
  tmp.minutes.give <- vector()
  tmp.minutes.receive <- vector()
  tmp.names <- vector()
  tmp.ranks <- vector()
  tmp.obs <- vector()
  tmp.group <- vector()
  
  for (i in unique(groom.tot$ID1)){
    tmp <- subset(groom.tot, groom.tot$phase == sgePhase)
    tmp2 <- sum(subset(tmp, tmp$ID1 == i)$min)
    tmp3 <- sum(subset(tmp, tmp$ID1 == i)$ID1.groom.min)
    tmp4 <- tmp2 - tmp3
    tmp.minutes <- cbind(tmp.minutes,tmp2)
    tmp.minutes.give <- cbind(tmp.minutes.give,tmp3)
    tmp.minutes.receive <- cbind(tmp.minutes.receive,tmp4)
    tmp.names <- cbind(tmp.names,i)
    tmp.ranks <- cbind(tmp.ranks,subset(tmp, tmp$ID1 == i)$ID1.rank[1])
    tmp.obs <- cbind(tmp.obs,subset(tmp, tmp$ID1 == i)$no.obs[1])
    tmp.group <- cbind(tmp.group,subset(tmp, tmp$ID1 == i)$group[1])
  }  
  
  sge.groom.rate.df <- as.data.frame(t(rbind(tmp.names,tmp.ranks,tmp.minutes,tmp.minutes.give,tmp.minutes.receive,tmp.obs,tmp.group)))
  names(sge.groom.rate.df) <- c('ID','elo','min','min.give','min.receive','no.obs','group')
  sge.groom.rate.df <- na.omit(sge.groom.rate.df)
  sge.groom.rate.df$elo <- as.numeric(as.character(sge.groom.rate.df$elo))
  sge.groom.rate.df$min <- as.numeric(as.character(sge.groom.rate.df$min))
  sge.groom.rate.df$min.give <- as.numeric(as.character(sge.groom.rate.df$min.give))
  sge.groom.rate.df$min.receive <- as.numeric(as.character(sge.groom.rate.df$min.receive))
  sge.groom.rate.df$no.obs <- as.numeric(as.character(sge.groom.rate.df$no.obs))
  sge.groom.rate.df$phase <- sgePhase
  
  ### Agonisms Received
  agg <- vector()
  name <- vector()
  group <- vector()
  
  for (i in unique(intro_phase$group)){
    tmp3 <- agg.received[[i]]$Group.1
    tmp4 <- agg.received[[i]]$x
    tmp5 <- rep(i,length(tmp3))
    agg <- c(agg,tmp4)
    name <- c(name,tmp3)
    group <- c(group,tmp5)
  }
  
  tmp <- as.data.frame(cbind(agg,name,group))
  tmp <- tmp[!(tmp$name=="ZZ"),]
  tmp$agg <- as.numeric(as.character(tmp$agg))
  tmp$name <- toupper(tmp$name)
  tmp$id.group <- paste(tmp$name,tmp$group, sep='_')
  
  intro_sub <- intro_phase
  intro_sub$agg.received <- 0
  intro_sub$id.group <- paste(intro_sub$ID,intro_sub$group, sep='_')
  tmp <- subset(tmp, tmp$id.group %in% intro_sub$id.group)
  intro_sub <- subset(intro_sub, intro_sub$id.group %in% tmp$id.group)
  intro_sub <- intro_sub[match(tmp$id.group, intro_sub$id.group),]
  intro_sub <- na.omit(intro_sub)
  intro_sub$agg.received <- tmp$agg
  
  # add zero rows back in
  intro_phase$id.group <- paste(intro_phase$ID,intro_phase$group, sep='_')
  tmp <- subset(intro_phase, !(intro_phase$id.group %in% intro_sub$id.group))
  tmp$agg.received <- 0
  intro_sub <- rbind.data.frame(intro_sub,tmp)
  ####
  
  
  ### Elo Function
  intro_sub$eloID <- ""
  intro_sub$calcElo <- 0
  intro_sub$groupEloStab <- 0
  
  ### Repeat For Each Group
  
  groupIDs <- names(dominance)
  g <- groupIDs[2]
  
  if (massCalcElo == TRUE) {
    domAll <- do.call(rbind.data.frame, dominance)
    
    domAll <- domAll[order(domAll$Date),]

    #seqcheck(groupDom$Winner,groupDom$Loser,groupDom$Date)

    #only distinct interactions
    domAllElo <- subset(domAll, Winner != Loser)
    elo <- elo.seq(domAllElo$Winner,domAllElo$Loser,domAllElo$Date)
    eloVals <- extract_elo(elo)
    names(eloVals) <- toupper(names(eloVals))
    
  } else {
  
    for (g in groupIDs) {
      groupNum <- which(groupIDs == g)
      groupDom <- as.data.frame(dominance[groupNum])
      
  
      colnames(groupDom) <- c("Date","Time","Winner","Loser")
      #colnames(groupDom) <- c("Date","Time","Winner","Loser")
      
      groupDom <- groupDom[order(groupDom$Date),]
      
      #seqcheck(groupDom$Winner,groupDom$Loser,groupDom$Date)
      
      #only distinct interactions
      groupDomElo <- subset(groupDom, Winner != Loser)
      elo <- elo.seq(groupDomElo$Winner,groupDomElo$Loser,groupDomElo$Date)
      eloVals <- extract_elo(elo)
      names(eloVals) <- toupper(names(eloVals))
      
      groupStab <- stab_elo(elo)
      
      intro_sub$groupEloStab[which(intro_sub$group == g)] <- groupStab
      
      for (i in names(eloVals)) {
        eloNum <- which(names(eloVals) == i)
        intro_sub$calcElo[which(intro_sub$ID == i)] <- eloVals[eloNum]
        intro_sub$eloID[which(intro_sub$ID == i)] <- names(eloVals)[eloNum]
      }
    }
  }
  
  ### Combine and Output Data
  sge.behave.summary <- merge(intro_sub,
                              sge.groom.rate.df, 
                              by = "ID",
                              suffixes = c(".agg",".groom"))
  
  
  sge.behave.summary$rawGroomRate <- (sge.behave.summary$min / sge.behave.summary$num.obs ) * 2
  sge.behave.summary$rawAggRecRate <- (sge.behave.summary$agg.received / sge.behave.summary$num.obs ) * 2
  
  
  
  ### drop DV / DVJ2
  ###
  ### here DV / DVJ2 is dropped from the group-centering process, NOT the calculation of all behaviors
  ### so when another animal won an Elo bout against DV2J she still benefitted
  ### but that group's averages are different without the inclusion of DV2J
  
  sge.behave.summary <- subset(sge.behave.summary, ID != "DV")
  
  #other dropped individuals:
  if (sgePhase == 1) {
    #sge.behave.summary <- subset(sge.behave.summary, ID != "IK")
    #sge.behave.summary <- subset(sge.behave.summary, ID != "PZ")
  } else if (sgePhase == 2) {
    #sge.behave.summary <- subset(sge.behave.summary, ID != "NN")
  }
  
  sge.behave.summary$groupcent_groom <- 0
  sge.behave.summary$groupcent_agRec <- 0
  sge.behave.summary$groupcent_elo <- 0
  sge.behave.summary$group.gc <- ""
  
  behaveCols <- which(colnames(sge.behave.summary) %in% c("ID",
                                                  "rawGroomRate",
                                                  "rawAggRecRate",
                                                  "calcElo"))
  
  #group center behavior rates
  for (g in sort(unique(sge.behave.summary$group.agg))) {
    print(g)
    groupBehave <- subset(sge.behave.summary, group.agg == g)[,behaveCols]
    
    newGroom <- scale(groupBehave[,3], center = TRUE, scale = FALSE)
    newAgRec <- scale(groupBehave[,4], center = TRUE, scale = FALSE)
    newElo <- scale(groupBehave[,2], center = TRUE, scale = FALSE)
    
    groupBehave$groupcent_elo <- newElo
    groupBehave$groupcent_groom <- newGroom
    groupBehave$groupcent_agRec <- newAgRec
    
    for (i in groupBehave$ID) {
      sge.behave.summary$group.gc[which(sge.behave.summary$ID == i)] <- g
      
      sge.behave.summary$groupcent_elo[which(sge.behave.summary$ID == i)] <- groupBehave$groupcent_elo[which(groupBehave$ID == i)]
      sge.behave.summary$groupcent_groom[which(sge.behave.summary$ID == i)] <- groupBehave$groupcent_groom[which(groupBehave$ID == i)]
      sge.behave.summary$groupcent_agRec[which(sge.behave.summary$ID == i)] <- groupBehave$groupcent_agRec[which(groupBehave$ID == i)]
    }
  }
  
  #add fraction kept to sge behave
  if (adjustData == FALSE) {
    sge.behave.summary$adjDate <- "WholePhase"
  } else {
    sge.behave.summary$adjDate <- samplingDate
  }
  sge.behave.summary$fractionKept <- 0
  sge.behave.summary$animalID <- ""
  
  for (i in sge.behave.summary$ID) {
    dfDateRow <- which(dateDF$twoLetter == i)
    behaveRow <- which(sge.behave.summary$ID == i)
    sge.behave.summary$animalID[behaveRow] <- dateDF$animal[dfDateRow]
    if (adjustData == FALSE) {
      sge.behave.summary$fractionKept[behaveRow] <- 1
    } else {
      sge.behave.summary$fractionKept[behaveRow] <- dateDF$fracKept[dfDateRow]
    }
  }
  
  
  ## cut down columns to bare minimum
  sge.behave.summary.full <- sge.behave.summary
  sge.behave.summary <- sge.behave.summary[,colnames(sge.behave.summary) %in% c("ID",
                                                                                "phase.agg",
                                                                                "group.agg",
                                                                                "rawGroomRate",
                                                                                "rawAggRecRate",
                                                                                "calcElo",
                                                                                "groupcent_groom",
                                                                                "groupcent_agRec",
                                                                                "groupcent_elo",
                                                                                "adjDate",
                                                                                "fractionKept",
                                                                                "animalID")]
  
  colnames(sge.behave.summary)[which(colnames(sge.behave.summary) == "phase.agg")] <- "phase"
  colnames(sge.behave.summary)[which(colnames(sge.behave.summary) == "group.agg")] <- "group"
  
  
  if ( adjustData == TRUE & sgePhase == 1 ) {
    write.table(x = sge.behave.summary.full,
                file = paste0(dataDir,"sge2Behavior_phase1_adj",samplingDate,"_noDVJ2.txt"),
                quote = FALSE, 
                sep = ",")
    write.table(x = sge.behave.summary,
                file = paste0(dataDir,"sge2Behavior_shortCols_phase1_adj",samplingDate,"_noDVJ2.txt"),
                quote = FALSE, 
                sep = ",")
  } else {
    write.table(x = sge.behave.summary.full,
                file = paste0(dataDir,"sge2Behavior_","phase",sgePhase,"_noDVJ2.txt"),
                quote = FALSE, 
                sep = ",")
    write.table(x = sge.behave.summary,
                file = paste0(dataDir,"sge2Behavior_shortCols_phase",sgePhase,"_noDVJ2.txt"),
                quote = FALSE, 
                sep = ",")
  }
}
```

```{r compare metadata}

sgePhase <- 1

#vaccine data v. Oct 2022 calc
sge.behave.summary <- read.csv2(file = paste0(dataDir,"sge2Behavior_shortCols_phase",sgePhase,"_noDVJ2.txt"),
                                 sep = ",", dec = ".")

sge.behave.summary.full <- read.csv2(file = paste0(dataDir,"sge2Behavior_phase",sgePhase,"_noDVJ2.txt"),
                                 sep = ",", dec = ".")

sge.vaccine.metadata <- readRDS(file = paste0("~/Dropbox (Personal)/macaque/vaccine/models/finalModel/output/metadata.RDS"))

#replace moonlight
sge.vaccine.metadata$twoLetterID <- gsub('77_06', 'mo', sge.vaccine.metadata$ind)
#drop leading R
sge.vaccine.metadata$twoLetterID <- gsub('^R', '', sge.vaccine.metadata$twoLetterID)
#uppercase/drop numbers
sge.vaccine.metadata$twoLetterID <- toupper(substr(sge.vaccine.metadata$twoLetterID, start = 1, stop = 2))

#are all the same animals present?
sge.vaccine.metadata$twoLetterID %in% sge.behave.summary$ID


##in vaccine data - "gc.overall.agg.rec","gc.elo","gc.overall.groom"

#drop the redundant rows in vaccine metadata
sge.vaccine.metadata.uniqueIND <- unique(sge.vaccine.metadata[,colnames(sge.vaccine.metadata) %in% c("group","ind","elo","rank","raw.groom.rate","raw.aggRec.rate","gc.overall.agg.rec","gc.overall.groom","gc.elo","twoLetterID")])

colnames(sge.behave.summary)[1] <- "twoLetterID"

sge.vaccine.metadata$twoLetterID %in% sge.behave.summary$twoLetterID


sgeBehaveComp <- merge(sge.vaccine.metadata.uniqueIND,
                       sge.behave.summary,
                       by = "twoLetterID",
                       suffixes = c("vax","pipeline"))


ggplot(data = sgeBehaveComp, aes(x = raw.groom.rate,
                                 y = rawGroomRate)) +
  geom_point() +
  xlab("Raw Groom Rate - Vaccine Data") +
  ylab("Raw Groom Rate - Pipeline Oct-2022 (github markdown)")

ggplot(data = sgeBehaveComp, aes(x = raw.aggRec.rate,
                                 y = rawAggRecRate)) +
  geom_point() +
  xlab("Raw AgRec Rate - Vaccine Data") +
  ylab("Raw AgRec Rate - Pipeline Oct-2022 (github markdown)")

ggplot(data = sgeBehaveComp, aes(x = elo,
                                 y = calcElo)) +
  geom_point() +
  xlab("Elo - Vaccine Data") +
  ylab("Elo - Pipeline Oct-2022 (github markdown)")
  
ggplot(data = sgeBehaveComp, aes(x = elo,
                                 y = calcElo,
                                 col = groupvax)) +
  geom_abline(slope = 1, intercept = 0) +
  geom_point(size = 3, alpha = .5) +
  xlab("Elo - Vaccine Data") +
  ylab("Elo - Pipeline Oct-2022 (github markdown)")




ggplot(data = sgeBehaveComp, aes(x = gc.overall.groom,
                                 y = groupcent_groom,
                                 col = groupvax)) +
  geom_point() +
  xlab("Group-Centered Groom Rate - Vaccine Data") +
  ylab("Group-Centered Groom Rate - Pipeline Oct-2022 (github markdown)")

#NSPF3 & NSPF5

ggplot(data = sgeBehaveComp, aes(x = gc.overall.agg.rec,
                                 y = groupcent_agRec,
                                 col = groupvax)) +
  geom_point() +
  xlab("Group-Centered AgRec Rate - Vaccine Data") +
  ylab("Group-Centered AgRec Rate - Pipeline Oct-2022 (github markdown)")

ggplot(data = sgeBehaveComp, aes(x = gc.elo,
                                 y = groupcent_elo,
                                 col = groupvax)) +
  geom_point() +
  xlab("Group-Centered Elo - Vaccine Data") +
  ylab("Group-Centered Elo - Pipeline Oct-2022 (github markdown)")

cor.test(x = sgeBehaveComp$gc.elo, y = sgeBehaveComp$groupcent_elo)
```

Bring in Noah's data
```{r}
#source("~/Dropbox (Personal)/macaque/vaccine/data/fromNoah/GenerateEloMatrices_SGE2.R")
# code to generate elo matrices across time frames 


# first generate elo objects 
library(EloRating)
library(reshape2)

agcodes<-c('tn','tc','at','ch')
subcodes<-c('wd','gr')

### CRC FIX added working directories manually
phase.I.directories <- c(paste0(dataDir,"fromNoah/SGE_Text_Files/PHASE_ONE/NSPF1/"),
                         paste0(dataDir,"fromNoah/SGE_Text_Files/PHASE_ONE/NSPF2/"),
                         paste0(dataDir,"fromNoah/SGE_Text_Files/PHASE_ONE/NSPF3/"),
                         paste0(dataDir,"fromNoah/SGE_Text_Files/PHASE_ONE/NSPF4/"),
                         paste0(dataDir,"fromNoah/SGE_Text_Files/PHASE_ONE/NSPF5/"),
                         paste0(dataDir,"fromNoah/SGE_Text_Files/PHASE_ONE/SPF1/"),
                         paste0(dataDir,"fromNoah/SGE_Text_Files/PHASE_ONE/SPF2/"),
                         paste0(dataDir,"fromNoah/SGE_Text_Files/PHASE_ONE/SPF3/"),
                         paste0(dataDir,"fromNoah/SGE_Text_Files/PHASE_ONE/SPF4/"),
                         paste0(dataDir,"fromNoah/SGE_Text_Files/PHASE_ONE/SPF5/"))

phase.II.directories <- c(paste0(dataDir,"fromNoah/SGE_Text_Files/PHASE_TWO/NSPF1/"),
                          paste0(dataDir,"fromNoah/SGE_Text_Files/PHASE_TWO/NSPF2/"),
                          paste0(dataDir,"fromNoah/SGE_Text_Files/PHASE_TWO/NSPF3/"),
                          paste0(dataDir,"fromNoah/SGE_Text_Files/PHASE_TWO/NSPF4/"),
                          paste0(dataDir,"fromNoah/SGE_Text_Files/PHASE_TWO/NSPF5/"),
                          paste0(dataDir,"fromNoah/SGE_Text_Files/PHASE_TWO/SPF1/"),
                          paste0(dataDir,"fromNoah/SGE_Text_Files/PHASE_TWO/SPF2/"),
                          paste0(dataDir,"fromNoah/SGE_Text_Files/PHASE_TWO/SPF3/"),
                          paste0(dataDir,"fromNoah/SGE_Text_Files/PHASE_TWO/SPF4/"),
                          paste0(dataDir,"fromNoah/SGE_Text_Files/PHASE_TWO/SPF5/"))

#define function convert.dom, which separates out each observation into actor and actee, defines winners and losers depending on whether it's an aggressive or submissive encounter, and gets rid of observations if they are not agonisms
convert.dom=function(x){ #x will be an item in a list, so one observation's worth of data
  x[,1]<-as.character(x[,1]) #convert first column, which is treated as a factor, to characters
  x[,4]<-NA #column for whether it's a usable interaction
  x[,5]<-NA #column for winner (if usable)
  x[,6]<-NA #column for loser (if usable)
  for(i in 1:nrow(x)){
    actor<-substr(as.character(x[i,1]),1,2)
    code<-substr(as.character(x[i,1]),3,4)
    actee<-substr(as.character(x[i,1]),5,6)  
    if(code%in%agcodes==TRUE){
      x[i,4]<-1
      x[i,5]<-actor
      x[i,6]<-actee
    } else if(code%in%subcodes==TRUE){
      x[i,4]<-1
      x[i,5]<-actee
      x[i,6]<-actor
    } else x[i,4]<-0
  }
  x<-x[x[,4]==1,]
  names(x)<-c('obs','time','date','agonism','winner','loser')
  return(x)
}

for (i in phase.I.directories){
  #setwd(i)
  
  #turn obs data into a single list, one file's worth of obs per list element
  #data<-lapply(list.files(pattern="*.txt"), function(x){read.table(x, header=T,sep="\t")})
  ### CRC FIX - setwd doesn't work in Rmd
  data<-lapply(paste0(i,list.files(i)[-length(list.files(i))]), function(x){read.table(x, header=T,sep="\t")})
  
  #function to add dates to matrix (I don't think we need either the start of observation time or the file number of the obs here)--gets rid of any dependencies on exact character number in the string and reformats date to the format expected by EloRating
  data<-lapply(data, function(x) {
    obsdate<-as.Date(unlist(strsplit(as.character(x[1,1]),":"))[2],"%m/%d/%Y")
    #identify header and comment rows, which begin with "H" to strip out
    headrows<-substr(as.character(x[,1]),1,1)!="H"
    t<-data.frame(do.call(rbind,strsplit(as.character(x[headrows,]),",")))
    t[,3]<-obsdate
    return(t)
  })
  
  #apply the function to the data and bind all the dataframes in the list into a single dataframe
  dominance<-lapply(data,convert.dom)
  all_data <- do.call(rbind, dominance)
  
  #note that there is an option to supply presence/absence data, which wouldn't affect most of our data, but there are some subset of obs where an individual was missing--consider supplying
  
  all_data <- subset(all_data, winner != loser)
  all_data <- all_data[order(all_data$date),]
  
  ###CRC FIX -- presence file
  #tmp <- paste(getwd(),'/',strsplit(getwd(), "/")[[1]][6],'_1_presence',sep = '')
  tmp <- paste0(i,list.files(i)[length(list.files(i))])
  presence_matrix <- read.delim(tmp, stringsAsFactors=FALSE)
  presence_matrix$Date  <- as.Date(as.character(presence_matrix$Date), "%m/%d/%Y")
  
  for (i in 2:ncol(presence_matrix)){
    presence_matrix[,i] <- as.numeric(presence_matrix[,i])
  }
  
  seqcheck(all_data$winner,all_data$loser,all_data$date)
  elo<-elo.seq(all_data$winner,all_data$loser,all_data$date)
  ###CRC FIX
  ###assign(value = elo, x=paste("np_elo_", strsplit(getwd(), "/")[[1]][6],'_1', sep=""));
  assign(value = elo, x=paste("np_elo_",strsplit(tmp, "/")[[1]][9],'_1', sep=""));
}

for (i in phase.II.directories){
  #setwd(i)
  
  #turn obs data into a single list, one file's worth of obs per list element
  #data<-lapply(list.files(pattern="*.txt"), function(x){read.table(x, header=T,sep="\t")})
  ### CRC FIX - setwd doesn't work in Rmd
  data<-lapply(paste0(i,list.files(i)[-length(list.files(i))]), function(x){read.table(x, header=T,sep="\t")})

  
  data<-lapply(data, function(x) {
    obsdate<-as.Date(unlist(strsplit(as.character(x[1,1]),":"))[2],"%m/%d/%Y")
    #identify header and comment rows, which begin with "H" to strip out
    headrows<-substr(as.character(x[,1]),1,1)!="H"
    t<-data.frame(do.call(rbind,strsplit(as.character(x[headrows,]),",")))
    t[,3]<-obsdate
    return(t)
  })
  
  #apply the function to the data and bind all the dataframes in the list into a single dataframe
  dominance<-lapply(data,convert.dom)
  all_data <- do.call(rbind, dominance)
  
  #note that there is an option to supply presence/absence data, which wouldn't affect most of our data, but there are some subset of obs where an individual was missing--consider supplying
  
  all_data <- subset(all_data, winner != loser)
  all_data <- all_data[order(all_data$date),]
  
  ###CRC FIX -- presence file
  #tmp <- paste(getwd(),'/',strsplit(getwd(), "/")[[1]][6],'_1_presence',sep = '')
  tmp <- paste0(i,list.files(i)[length(list.files(i))])
  presence_matrix <- read.delim(tmp, stringsAsFactors=FALSE)
  presence_matrix$Date  <- as.Date(as.character(presence_matrix$Date), "%m/%d/%Y")
  
  for (i in 2:ncol(presence_matrix)){
    presence_matrix[,i] <- as.numeric(presence_matrix[,i])
  }
  
  seqcheck(all_data$winner,all_data$loser,all_data$date)
  elo<-elo.seq(all_data$winner,all_data$loser,all_data$date)
  ###CRCFIX
  ###assign(value = elo, x=paste("np_elo_", strsplit(getwd(), "/")[[1]][6],'_1', sep=""));
  assign(value = elo, x=paste("np_elo_",strsplit(tmp, "/")[[1]][9], sep=""));

}


#### Ok now generate the elo matrices
## Phase I
p1_elos <- c('np_elo_NSPF1_1',
             'np_elo_NSPF2_1',
             'np_elo_NSPF3_1',
             'np_elo_NSPF4_1',
             'np_elo_NSPF5_1',
             'np_elo_SPF1_1',
             'np_elo_SPF2_1',
             'np_elo_SPF3_1',
             'np_elo_SPF4_1',
             'np_elo_SPF5_1')

for (i in p1_elos){
  tmp <- get(i)
  print(i)
  print(tmp$truedates[1])
  print(tmp$truedates[length(tmp$truedates)])
}

phase.I.dates <- data.frame(matrix(nrow = 351))
rownames(phase.I.dates) <- seq(as.Date("2018-03-08"), as.Date("2019-02-21"), by="days")

for (i in p1_elos){
  tmp <- get(i)
  tmp2 <- tmp$cmat
  rownames(tmp2) <- as.character(tmp$truedates)
  phase.I.dates <- transform(merge(phase.I.dates,tmp2,by=0,all=TRUE), row.names=Row.names, Row.names=NULL)
}

phase.I.elo.matrix <- phase.I.dates
phase.I.elo.matrix$matrix.nrow...351. <- NULL

## Phase II

p2_elos <- c('np_elo_NSPF1',
             'np_elo_NSPF2',
             'np_elo_NSPF3',
             'np_elo_NSPF4',
             'np_elo_NSPF5',
             'np_elo_SPF1',
             'np_elo_SPF2',
             'np_elo_SPF3',
             'np_elo_SPF4',
             'np_elo_SPF5')
for (i in p2_elos){
  tmp <- get(i)
  print(i)
  print(tmp$truedates[1])
  print(tmp$truedates[length(tmp$truedates)])
}

phase.II.dates <- data.frame(matrix(nrow = 248))
rownames(phase.II.dates) <- seq(as.Date("2019-05-07"), as.Date("2020-01-09"), by="days")

for (i in p2_elos){
  tmp <- get(i)
  tmp2 <- tmp$cmat
  rownames(tmp2) <- as.character(tmp$truedates)
  phase.II.dates <- transform(merge(phase.II.dates,tmp2,by=0,all=TRUE), row.names=Row.names, Row.names=NULL)
}

phase.II.elo.matrix <- phase.II.dates
phase.II.elo.matrix$matrix.nrow...248. <- NULL
colnames(phase.II.elo.matrix)[19] <- 'dj'
colnames(phase.II.elo.matrix)[43] <- 'dj15'

# get elos for a specific date with > phase.I.elo.matrix['2018-11-03',]


#### Check github matrices
phase.I.elo.GitHub <- read.delim("https://raw.githubusercontent.com/mauriziopaul/sge_share/master/data/elo_matrices/phase.I.elo.matrix?token=GHSAT0AAAAAABY77D5V7QBYW3SSIYF7LBEEY2KVLYA")

phase.II.elo.GitHub <- read.delim("https://raw.githubusercontent.com/mauriziopaul/sge_share/master/data/elo_matrices/phase.II.elo.matrix?token=GHSAT0AAAAAABY77D5UQSFODMQMNNRX4X4AY2KVMYA")

sum(!phase.I.elo.matrix == phase.I.elo.GitHub, na.rm = TRUE)
sum(!phase.II.elo.matrix == phase.II.elo.GitHub, na.rm = TRUE)

```

Noah's data - using sampling dates

current status
-the sampling dates in pseudobulk-info don't generate the correct elo
-printing the dates that match the pesudobulk info elo's i can reverse engineer the dates that were used


```{r}
# get elos for a specific date with > phase.I.elo.matrix['2018-11-03',]
# 
pseudobulkMetaData <- read.delim("https://raw.githubusercontent.com/mauriziopaul/sge_share/master/data/pseudobulk_info.csv?token=GHSAT0AAAAAABY77D5VVYUYPGVZNF2GKIFYY2MEZ6A", sep = ",")

pseudobulkMetaData <- subset(pseudobulkMetaData, trt == "NC")

pseudobulkMetaData$dateReformat <- ""
pseudobulkMetaData$manualElo <- 0
pseudobulkMetaData$envChallElo <- 0
#pseudobulkMetaData$manualLastElo <- 0



#resort by group
#pseudobulkMetaData <- pseudobulkMetaData[order(pseudobulkMetaData$group),]

for (i in 1:length(pseudobulkMetaData$sample.date)) {
  if (pseudobulkMetaData$caps_ID[i] %in% toupper(colnames(phase.I.elo.matrix))) {
    dateString <- strsplit(pseudobulkMetaData$sample.date[i],split = "-")[[1]]
    dateString <- gsub(dateString, pattern = "Oct", replacement = "10")
    pseudobulkMetaData$dateReformat[i] <- paste0("20",dateString[3],"-",dateString[2],"-",sprintf("%02d", as.numeric(dateString[1])))
    
    eloMatCol <- which(toupper(colnames(phase.I.elo.matrix)) == pseudobulkMetaData$caps_ID[i])
    pseudobulkMetaData$manualElo[i] <- phase.I.elo.matrix[pseudobulkMetaData$dateReformat[i],eloMatCol]
    #pseudobulkMetaData$manualLastElo[i] <- phase.I.elo.matrix['2018-10-18',eloMatCol]
    
    ecDate <- unique(sampleDates$dateEnvChall[which(sampleDates$group == pseudobulkMetaData$group[i])])[1]
    
    
    pseudobulkMetaData$envChallElo[i] <- phase.I.elo.matrix[ecDate,eloMatCol]
    #PRINT THE DATES THAT MATCH
    #print(paste0(pseudobulkMetaData$caps_ID[i]," ",pseudobulkMetaData$group[i]))
    
    #matchDates <- which(phase.I.elo.matrix[,eloMatCol] == pseudobulkMetaData$elo_orig[i])
    #print(rownames(phase.I.elo.matrix)[matchDates])
    #print("---------------")
  }
}

ggplot(data = pseudobulkMetaData,
       aes(x = elo_orig,
           y = manualElo,
           col = group %in% unique(subset(sampleDates, seasonEnvChall == "fall")$group))) +
  geom_abline(slope = 1, intercept = 0, alpha = .5) +
  geom_point() +
  labs(col = "EC & Single Cell\nSampled Together") +
  xlab("Elo from Paul's Analysis") +
  ylab("Noah's Elo - Date of Single Cell")

ggplot(data = pseudobulkMetaData,
       aes(x = elo_orig,
           y = manualElo)) +
  geom_abline(slope = 1, intercept = 0, alpha = .5) +
  geom_point() +
  labs(col = "EC & Single Cell\nSampled Together") +
  xlab("Elo from Paul's Analysis") +
  ylab("Noah's Elo - Date of Single Cell")

ggplot(data = pseudobulkMetaData,
       aes(x = elo_orig,
           y = envChallElo,
           col = group)) +
  geom_abline(slope = 1, intercept = 0, alpha = .5) +
  geom_point() +
  xlab("Elo from Paul's Analysis") +
  ylab("Noah's Elo - Date of EnvChall")
  
  



```



Bring in Paul's data
```{r}
#sge2paulFile <- "https://github.com/mauriziopaul/sge_share/blob/master/data/sge.II.behavioral.v2.txt"
sge2paulRaw <- read.delim((paste0("~/Dropbox (Personal)/macaque/vaccine/data/sge.II.behavioral.v2.txt")))

##### Paul's code:

## Drop Phase II, Drop DV2J
sge2paulRaw <- droplevels(sge2paulRaw[sge2paulRaw$phase=='1' & !(sge2paulRaw$ID=="DV"),])
sge2paulRaw$gc.overall.agg.rec <- sge2paulRaw$gc.overall.groom <- NA
sge2paulRaw$mc.overall.agg.rec <- sge2paulRaw$mc.overall.groom <- NA
sge2paulRaw$groom.group.mean <- NA

## Two approaches:
## (1) Drop DV2J, mean center covariate across all 48 individuals ("gc")
## (2) Drop DV2J, mean center covariate within group, mean center covariate across all 48 individuals ("mc")

## mean center within group
for (i in unique(sge2paulRaw$group)){
  sge2paulRaw[sge2paulRaw$group==i,"gc.overall.agg.rec"] <- scale(sge2paulRaw[sge2paulRaw$group==i,"raw.aggRec.rate"], scale=F, center=T)[,1]
  sge2paulRaw[sge2paulRaw$group==i,"gc.overall.groom"] <- scale(sge2paulRaw[sge2paulRaw$group==i,"raw.groom.rate"], scale=F, center=T)[,1]
  sge2paulRaw[sge2paulRaw$group==i,"raw.groom.group.mean"] <- mean(sge2paulRaw[sge2paulRaw$group==i,"raw.groom.rate"], na.rm=TRUE)
}

## mean center across all animals
covs <- c("gc.overall.agg.rec", "gc.overall.groom", "mc.overall.agg.rec", "mc.overall.groom", "groom.group.mean")
for(cov in c("gc.overall.agg.rec", "gc.overall.groom")){sge2paulRaw[,cov] <- scale(sge2paulRaw[,cov], scale=F, center=T)[,1]}
sge2paulRaw[,"mc.overall.agg.rec"] <- scale(sge2paulRaw[,"raw.aggRec.rate"], scale=F, center=T)[,1]
sge2paulRaw[,"mc.overall.groom"] <- scale(sge2paulRaw[,"raw.groom.rate"], scale=F, center=T)[,1]
sge2paulRaw[,"groom.group.mean"] <- scale(sge2paulRaw[,"raw.groom.group.mean"], scale=F, center=T)[,1]
#sge2paulRaw <- sge2paulRaw[,c("ID", covs)]
### keeping a little more info
sge2paulRaw <- sge2paulRaw[,c("ID", "group", "phase", "elo", covs)]

### i think this is where paul compares his data back to some other data, so i'm dropping it



```


```{r compare my data with pauls}
sgePhase <- 1

#vaccine data v. Oct 2022 calc
sge.behave.summary <- read.csv2(file = paste0(dataDir,"sge2Behavior_shortCols_phase",sgePhase,"_noDVJ2.txt"),
                                 sep = ",", dec = ".")

sge.behave.summary.full <- read.csv2(file = paste0(dataDir,"sge2Behavior_phase",sgePhase,"_noDVJ2.txt"),
                                 sep = ",", dec = ".")

sge.vaccine.metadata <- readRDS(file = paste0("~/Dropbox (Personal)/macaque/vaccine/models/finalModel/output/metadata.RDS"))

#replace moonlight
sge.vaccine.metadata$twoLetterID <- gsub('77_06', 'mo', sge.vaccine.metadata$ind)
#drop leading R
sge.vaccine.metadata$twoLetterID <- gsub('^R', '', sge.vaccine.metadata$twoLetterID)
#uppercase/drop numbers
sge.vaccine.metadata$twoLetterID <- toupper(substr(sge.vaccine.metadata$twoLetterID, start = 1, stop = 2))

#are all the same animals present?
sge.vaccine.metadata$twoLetterID %in% sge.behave.summary$ID


##in vaccine data - "gc.overall.agg.rec","gc.elo","gc.overall.groom"

#drop the redundant rows in vaccine metadata
sge.vaccine.metadata.uniqueIND <- unique(sge.vaccine.metadata[,colnames(sge.vaccine.metadata) %in% c("group","ind","elo","rank","raw.groom.rate","raw.aggRec.rate","gc.overall.agg.rec","gc.overall.groom","gc.elo","twoLetterID")])

colnames(sge.behave.summary)[1] <- "twoLetterID"

sge.vaccine.metadata$twoLetterID %in% sge.behave.summary$twoLetterID


sgeBehaveComp <- merge(sge.vaccine.metadata.uniqueIND,
                       sge.behave.summary,
                       by = "twoLetterID",
                       suffixes = c(".vax",".pipeline"))


sgeBehaveComp$twoLetterID %in% sge2paulRaw$ID
sge2paulRaw$ID %in% sgeBehaveComp$twoLetterID
colnames(sgeBehaveComp)
colnames(sge2paulRaw)

colnames(sgeBehaveComp)[which(colnames(sgeBehaveComp) == "twoLetterID")] <- "ID"

paulBehaveComp <- merge(sgeBehaveComp,
                        sge2paulRaw,
                        by = "ID",
                        suffixes = c(".vax",".paul"))

ggplot(data = paulBehaveComp,
       aes(x = gc.overall.groom.paul,
           y = gc.overall.groom.vax)) +
  geom_point() +
  xlab("Group-Centered Groom - Paul") +
  ylab("Group-Centered Groom - Vaccine")

ggplot(data = paulBehaveComp,
       aes(x = gc.overall.groom.paul,
           y = groupcent_groom)) +
  geom_point() +
  xlab("Group-Centered Groom - Paul") +
  ylab("Group-Centered Groom - Pipeline\nOct-2022 (kept RPz13 & RIk6)")

ggplot(data = paulBehaveComp,
       aes(x = gc.overall.agg.rec.paul,
           y = gc.overall.agg.rec.vax)) +
  geom_point() +
  xlab("Group-Centered AgRec - Paul") +
  ylab("Group-Centered AgRec - Vaccine")

ggplot(data = paulBehaveComp,
       aes(x = gc.overall.agg.rec.paul,
           y = groupcent_agRec)) +
  geom_point() +
  xlab("Group-Centered AgRec - Paul") +
  ylab("Group-Centered AgRec - Pipeline\nOct-2022 (kept RPz13 & RIk6)")


ggplot(data = paulBehaveComp,
       aes(x = elo.paul,
           y = elo.vax)) +
  geom_point() +
  xlab("Elo - Paul") +
  ylab("Group-Centered Groom - Vaccine")

ggplot(data = paulBehaveComp,
       aes(x = elo.paul,
           y = calcElo)) +
  geom_point() +
  xlab("Elo - Paul") +
  ylab("Group-Centered Elo - Pipeline\nOct-2022 (kept RPz13 & RIk6)")

cor.test(paulBehaveComp$gc.overall.groom.vax, paulBehaveComp$groupcent_groom)
cor.test(paulBehaveComp$gc.overall.agg.rec.vax, paulBehaveComp$groupcent_agRec)

```

```{r compare noahs data with all}

twoLet <- paulBehaveComp$ID[14]
paulBehaveComp$noahElo <- 0

colnames(phase.I.elo.matrix)[which(colnames(phase.I.elo.matrix) == "e2")] <- "et"

for (twoLet in paulBehaveComp$ID) {
  matCol <- which(toupper(colnames(phase.I.elo.matrix)) == twoLet)
  behavRow <- which(paulBehaveComp$ID == twoLet)
  indEloVector <- phase.I.elo.matrix[,matCol]
  indEloVector <- indEloVector[!is.na(indEloVector)]
  indElo <- indEloVector[length(indEloVector)]
  paulBehaveComp$noahElo[behavRow] <- indElo
}

ggplot(data = paulBehaveComp,
       aes(x = elo.paul,
           y = noahElo)) +
  geom_point() +
  xlab("Elo - Paul") +
  ylab("noah Elo")

ggplot(data = paulBehaveComp,
       aes(x = calcElo,
           y = noahElo,
           col = group.vax)) +
  geom_point() +
  xlab("pipeline elo") +
  ylab("noah Elo")

ggplot(data = paulBehaveComp,
       aes(x = elo.vax,
           y = noahElo)) +
  geom_point() +
  xlab("vaccine elo") +
  ylab("noah Elo")

```


Compare SGE2 phase 2 behavior numbers
```{r}
sgePhase <- 2

#vaccine data v. Oct 2022 calc
sge.behave.summary <- read.csv2(file = paste0(dataDir,"sge2Behavior_shortCols_phase",sgePhase,"_noDVJ2.txt"),
                                 sep = ",", dec = ".")

sge.behave.summary.full <- read.csv2(file = paste0(dataDir,"sge2Behavior_phase",sgePhase,"_noDVJ2.txt"),
                                 sep = ",", dec = ".")

sge.vaccine.metadata <- read.csv2(file = paste0("~/Dropbox (Personal)/macaque/vaccine/data/sge2Behavior_phase_2_noDVJ2.txt"),
                                  sep = ",", dec = ".")
sgePhase2Comp <- merge(sge.behave.summary,
                       sge.vaccine.metadata,
                       by = "ID",
                       suffixes = c(".pipe",".vax"))


ggplot(data = sgePhase2Comp,
       aes(x = groupcent_groom.vax,
           y = groupcent_groom.pipe)) +
  geom_point() +
  xlab("GC Groom - Vaccine") +
  ylab("GC Groom - Pipeline Oct-2022")

ggplot(data = sgePhase2Comp,
       aes(x = groupcent_agRec.vax,
           y = groupcent_agRec.pipe)) +
  geom_point() +
  xlab("GC AgRec - Vaccine") +
  ylab("GC AgRec - Pipeline Oct-2022")

ggplot(data = sgePhase2Comp,
       aes(x = groupcent_elo.vax,
           y = groupcent_elo.pipe)) +
  geom_point() +
  xlab("Elo - Vaccine") +
  ylab("Elo - Pipeline Oct-2022")

cor.test(sgePhase2Comp$groupcent_elo.pipe, sgePhase2Comp$groupcent_elo.vax)

cor.test(sgePhase2Comp$groupcent_groom.pipe, sgePhase2Comp$groupcent_groom.vax)
cor.test(sgePhase2Comp$groupcent_agRec.pipe, sgePhase2Comp$groupcent_agRec.vax)

#bring in Noah's phase 2 numbers
twoLet <- sgePhase2Comp$ID[14]
sgePhase2Comp$noahElo <- 0
sgePhase2Comp$noahEnvChallElo <- 0

colnames(phase.II.elo.matrix)[which(colnames(phase.II.elo.matrix) == "e2")] <- "et"
#colnames(phase.II.elo.matrix)[which(colnames(phase.II.elo.matrix) == "dj")] <- "d2"

for (twoLet in sgePhase2Comp$ID) {
  if (twoLet %in% toupper(colnames(phase.II.elo.matrix))) {
    matCol <- which(toupper(colnames(phase.II.elo.matrix)) == twoLet)
    behavRow <- which(sgePhase2Comp$ID == twoLet)
    indGroup <- subset(sgePhase2Comp, ID == twoLet)$group
    envChallDate <- subset(sampleDatesP2, group == indGroup & event == "envChall")$date
    indEloVector <- phase.II.elo.matrix[,matCol]
    indEloVector <- indEloVector[!is.na(indEloVector)]
    indElo <- indEloVector[length(indEloVector)]
    sgePhase2Comp$noahElo[behavRow] <- indElo
    sgePhase2Comp$noahEnvChallElo[behavRow] <- phase.II.elo.matrix[envChallDate,matCol]
  }
}

ggplot(data = sgePhase2Comp,
       aes(x = groupcent_elo.vax,
           y = noahElo)) +
  geom_abline(slope = 1, intercept = 1000) +
  geom_point() +
  xlab("Elo - Vaccine") +
  ylab("Elo - Noah")

ggplot(data = sgePhase2Comp,
       aes(x = groupcent_elo.pipe,
           y = noahElo,
           col = group)) +
  geom_point() +
  ggtitle("SGEII - Phase 2") +
  xlab("Elo - Pipeline") +
  ylab("Elo - Noah")

ggplot(data = sgePhase2Comp,
       aes(x = groupcent_elo.vax,
           y = noahEnvChallElo,
           col = group)) +
  geom_abline(slope = 1, intercept = 1000) +
  geom_point() +
  xlab("Elo - Vaccine") +
  ylab("Elo - Noah EnvChall Date")

```


Ryan, could you plot the correlation for Elo, grooming, and agonisms received, for using values at the time of sampling versus whole phase (this will be different for the three different major sampling efforts)?
```{r}

sgePhase <- 1
fullData <- read.table(file = paste0(dataDir,"sge2Behavior_shortCols_phase",sgePhase,"_noDVJ2.txt"),
                       sep = ",")

groupByGroup <- data.frame()

for (samplingDate in c("SingleCell","Vax","EnvChall")) {
  partialData <- read.table(file = paste0(dataDir,"sge2Behavior_shortCols_phase",sgePhase,"_adj",samplingDate,"_noDVJ2.txt"),
                            sep = ",")
  
  compareData <- merge(fullData,
                       partialData,
                       by = "animalID", suffixes = c(".full",".part"))
  
  avgKept <- round(mean(compareData$fractionKept.part), digits = 2)
  
  eloCorr <- round(cor.test(x = compareData$groupcent_elo.full,
                            y = compareData$groupcent_elo.part)$estimate, digits = 4)
  
  ggplot(data = compareData,
         aes(x = groupcent_elo.full,
             y = groupcent_elo.part)) +
    geom_smooth(method = "lm", formula = "y~x", se = FALSE, lwd = .5, col = "black") +
    geom_point(aes(col = group.part), size = 3) +
    labs(col = "Group") +
    ggtitle(paste0("Centered Elo: at ",samplingDate," v. Full - SGEII Phase ",sgePhase),
            subtitle = paste0(avgKept," of Phase Obs. used | R = ", eloCorr))
  
  ggsave(paste0(figDir,samplingDate,"vFull_centElo_XYplot.png"),
         width = 6, height = 4)

  agrCorr <- round(cor.test(x = compareData$groupcent_agRec.full,
                            y = compareData$groupcent_agRec.part)$estimate, digits = 4)
  
  ggplot(data = compareData,
         aes(x = groupcent_agRec.full,
             y = groupcent_agRec.part)) +
    geom_smooth(method = "lm", formula = "y~x", se = FALSE, lwd = .5, col = "black") +
    geom_point(aes(col = group.part), size = 3) +
    labs(col = "Group") +
    ggtitle(paste0("Centered AgRec: at ",samplingDate," v. Full - SGEII Phase ",sgePhase),
            subtitle = paste0(avgKept," of Phase Obs. used | R = ", agrCorr))
  
  ggsave(paste0(figDir,samplingDate,"vFull_centAgRec_XYplot.png"),
         width = 6, height = 4)

  grmCorr <- round(cor.test(x = compareData$groupcent_groom.full,
                            y = compareData$groupcent_groom.part)$estimate, digits = 4)
  
  ggplot(data = compareData,
         aes(x = groupcent_groom.full,
             y = groupcent_groom.part)) +
    geom_smooth(method = "lm", formula = "y~x", se = FALSE, lwd = .5, col = "black") +
    geom_point(aes(col = group.part), size = 3) +
    labs(col = "Group") +
    ggtitle(paste0("Centered Groom: at ",samplingDate," v. Full - SGEII Phase ",sgePhase),
            subtitle = paste0(avgKept," of Phase Obs. used | R = ", grmCorr))
  
    ggsave(paste0(figDir,samplingDate,"vFull_centGroom_XYplot.png"),
         width = 6, height = 4)

    groupByGroup <- rbind.data.frame(groupByGroup,
                                     unique(cbind.data.frame(compareData$fractionKept.part,compareData$group.part,compareData$adjDate.part)))
}

colnames(groupByGroup) <- c("obsKept","group","sampleDate")

ggplot(data = groupByGroup,
       aes(x = obsKept,
           y = sampleDate)) +
  geom_violin(col = "white") +
  geom_jitter(aes(col = group), size = 3, width = 0, height = .1) +
  xlim(c(0,1))

ggsave(paste0(figDir,"groupByGroup_observations_by_samplingpoint.png"),
         width = 6, height = 4)
```

