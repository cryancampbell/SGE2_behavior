---
title: "sge2_behavior_methods_script.Rmd"
output: html_document
date: "2022-10-20"
---

```{r setup, include=FALSE}
library(ggplot2)
library(ggrepel)
library(tidyverse)
library(data.table)
library(viridis)
library(cowplot)
library(grid)
library(EloRating)
library(dplyr)
library(lme4)

workDir <- getwd()
dataDir <- paste0(workDir,"/data/")
outDir <- paste0(workDir,"/output/")
figDir <- paste0(workDir,"/figures/")
if(!"data" %in% list.files(workDir)) {
  dir.create(dataDir)
}
if(!"output" %in% list.files(workDir)) {
  dir.create(outDir)
}
if(!"figures" %in% list.files(workDir)) {
  dir.create(figDir)
}

```

# Read Me
This is final code to generate group-centered Agonisms Received Rate, Overall Grooming Rate, and Elo for SGE2 phases 1 & 2.
This code will output behavioral values for all animals, for all 4 experiments (SGE2p1 Environmental Challenge, SGE2p1 Single Cell, SGE2p1 Vaccine, SGE2p2 Vaccine)
It will also generate dataset-specific numbers to complete a clear methods section (behavior_methods_text.txt)

# Gather Data
```{r input data}
#gather files
sampleDates <- read.table(paste0(dataDir,"samplingDatesForR.csv"), sep = ",", header = T)
sampleDatesP2 <- read.table(paste0(dataDir,"eventDatesPhase2.csv"), sep = ",", header = T)
#replace NONSPF with NSPF to match phase 1
sampleDatesP2$group <- gsub(pattern = "NO", replacement = "", sampleDatesP2$group)
#match event text in phase 2, vax -> Vax, envChall -> EnvChall
sampleDatesP2$event <- gsub(gsub(sampleDatesP2$event, pattern = "vax", replacement = "Vax"), pattern = "envChall",replacement = "EnvChall")

#death and clinic dates
clinicInfo <- read.csv(paste0(dataDir,"SGE_animal_deaths_and_clinic.csv"), sep = ",", dec = ".")
clinicInfo$DeathDate <- as.Date(clinicInfo$DeathDate)

groupStart <- read.csv(paste0(dataDir,"SGE_group_formation_dates.csv"), sep = ",", dec = ".")
groupStart$Phase1Completion <- as.Date(groupStart$Phase1Completion)
groupStart$Phase2Completion <- as.Date(groupStart$Phase2Completion)

intro_all <- "https://github.com/ndsimons/sge.II.obs.analysis/raw/master/obs.data/intro_all_v3.txt"
intro_all <- read.delim(intro_all)
intro_all$ID <- gsub('77_06', 'mo', intro_all$ID)
intro_all$ID <- gsub('Dj7', 'D2', intro_all$ID)

load(url("https://github.com/ndsimons/sge.II.obs.analysis/blob/master/obs.data/all.obs.files.RData?raw=true"))
SPF5_1$behavior <- gsub('e2', 'et', SPF5_1$behavior)
NSPF4$behavior <- gsub('dj', 'd2', NSPF4$behavior)

## add # of obs per individual to intros_all
data_list <- list(NSPF1 = NSPF1, NSPF2 = NSPF2, NSPF3 = NSPF3, NSPF4 = NSPF4, NSPF5 = NSPF5,
                  SPF1 = SPF1, SPF2 = SPF2, SPF3 = SPF3, SPF4 = SPF4, SPF5 = SPF5,
                  NSPF1_1 = NSPF1_1, NSPF2_1 = NSPF2_1, NSPF3_1 = NSPF3_1, NSPF4_1 = NSPF4_1, NSPF5_1 = NSPF5_1,
                  SPF1_1 = SPF1_1, SPF2_1 = SPF2_1, SPF3_1 = SPF3_1, SPF4_1 = SPF4_1, SPF5_1 = SPF5_1)

#behavior functions
load(url("https://github.com/ndsimons/sge.II.obs.analysis/blob/master/functions/behavior_functions.RData?raw=true"))

convert.dom.git <- function(x) {
  x<-cbind(x[,c(1,2)],matrix(nrow=nrow(x),ncol=3))
  date=0
  for (r in 1:nrow(x)) {
  	if (substr(x[r,1],1,5)=="HDATE") date=substr(x[r,1],7,20)
  	else if (substr(x[r,1],1,5)!="HDATE") {
  	  b<-substr(x[r,1],3,4)
  	  if (b%in%c("tn","tc","at","ch")) {
  	    x[r,3]<-substr(x[r,1],1,2); 
  	    x[r,4]<-substr(x[r,1],5,6)
  	  } else if (b%in%c("gr","wd")) {
  	      x[r,4]<-substr(x[r,1],1,2); 
  	      x[r,3]<-substr(x[r,1],5,6)};
  	  x[r,5]<-date
  	}
  }
  x<-(x[-which(is.na(x[,2])),])
  x<-(x[-which(is.na(x[,3])),])
  rownames(x)<-NULL
  x<-x[,c(2:5)]
  colnames(x)<-c("Time","Winner","Loser","Date")
  x<-x[,c(4,1:3)]
  x[,1]<-as.Date(x[,1],"%m/%d/%Y")
  return(x)
}

#need file of pulls + dates
clinicalPulls <- read.table(paste0(dataDir,"clinicalPulls_allSGE2_forR.csv"), 
                            sep = ",", header = T)

clinicalPulls$group_completion_date <- as.Date(clinicalPulls$group_completion_date)
clinicalPulls$clinical_date_in <- as.Date(clinicalPulls$clinical_date_in)
clinicalPulls$clinical_date_out <- as.Date(clinicalPulls$clinical_date_out)

#need file of sampling dates
samplingDates <- read.table(paste0(dataDir,"samplingDates_allSGE2_forR.csv"),
                            sep = ",", header = T)
samplingDates$dateSingleCellP1 <- as.Date(samplingDates$dateSingleCellP1)
samplingDates$dateEnvChallP1 <- as.Date(samplingDates$dateEnvChallP1)
samplingDates$dateVaxP1 <- as.Date(samplingDates$dateVaxP1)
samplingDates$dateEnvChallP2 <- as.Date(samplingDates$dateEnvChallP2)
samplingDates$dateLPS3moP2 <- as.Date(samplingDates$dateLPS3moP2)
samplingDates$dateLPS6moP2 <- as.Date(samplingDates$dateLPS6moP2)
samplingDates$dateLPS9moP2 <- as.Date(samplingDates$dateLPS9moP2)
samplingDates$dateVaxP2 <- as.Date(samplingDates$dateVaxP2)


```

# Generate animal presence/absence data, clinicial pulls and deaths

```{r clinical pulls and deaths}

for (sgePhase in c(1,2)) {
  
  if (sgePhase == 1) {
    #for every phase 1 animal
    allAnimals <- samplingDates$animal[!is.na(samplingDates$groupP1)]
  } else {
    allAnimals <- samplingDates$animal[!is.na(samplingDates$groupP2)]
  }
  
  #a <- allAnimals[14]
  #a <- allAnimals[31]
  
  animalVector <- vector()
  groupVector <- vector()
  eventVector <- vector()
  dateVector <- vector()
  
  for (a in allAnimals) {
    #get group
    grpID <- samplingDates[which(samplingDates$animal == a), which(colnames(samplingDates) == paste0("groupP",sgePhase))]
    #use april 1st as plot end date
    absentDates <- vector()
      if (sgePhase == 1) {
        plotEndDate <- max(max(samplingDates[,4], na.rm = TRUE),
                           max(samplingDates[,5], na.rm = TRUE),
                           max(samplingDates[,6], na.rm = TRUE)) + 60
        } else {
          allAnimals <- samplingDates$animal[!is.na(samplingDates$groupP2)]
          plotEndDate <- max(max(samplingDates[,8], na.rm = TRUE),
                             max(samplingDates[,9], na.rm = TRUE),
                             max(samplingDates[,10], na.rm = TRUE),
                             max(samplingDates[,11], na.rm = TRUE),
                             max(samplingDates[,12], na.rm = TRUE)) + 60
  }
    
    #get sampling dates
    ecDate <- samplingDates[which(samplingDates$animal == a), 
                            which(colnames(samplingDates) == paste0("dateEnvChallP",sgePhase))]
    if ( !is.na(ecDate) ) {
      animalVector <- c(animalVector, a)
      groupVector <- c(groupVector, grpID)
      eventVector <- c(eventVector, "envChall")
      dateVector <- c(dateVector, ecDate)
    }
    vaxDate <- samplingDates[which(samplingDates$animal == a), which(colnames(samplingDates) == paste0("dateVaxP",sgePhase))]
    if ( !is.na(vaxDate) ) {
      animalVector <- c(animalVector, a)
      groupVector <- c(groupVector, grpID)
      eventVector <- c(eventVector, "vaccine")
      dateVector <- c(dateVector, vaxDate)
    }
    
    if (sgePhase == 1) {
      scDate <- samplingDates$dateSingleCellP1[which(samplingDates$animal == a)]
      if ( !is.na(scDate) ) {
        animalVector <- c(animalVector, a)
        groupVector <- c(groupVector, grpID)
        eventVector <- c(eventVector, "singleCell")
        dateVector <- c(dateVector, scDate)
      }
    } else {
      lps3Date <- samplingDates$dateLPS3moP2[which(samplingDates$animal == a)]
      if ( !is.na(lps3Date) ) {
        animalVector <- c(animalVector, a)
        groupVector <- c(groupVector, grpID)
        eventVector <- c(eventVector, "lps3mo")
        dateVector <- c(dateVector, lps3Date)
      }
      lps6Date <- samplingDates$dateLPS6moP2[which(samplingDates$animal == a)]
      if ( !is.na(lps6Date) ) {
        animalVector <- c(animalVector, a)
        groupVector <- c(groupVector, grpID)
        eventVector <- c(eventVector, "lps6mo")
        dateVector <- c(dateVector, lps6Date)
      }
      lps9Date <- samplingDates$dateLPS9moP2[which(samplingDates$animal == a)]
      if ( !is.na(lps9Date) ) {
        animalVector <- c(animalVector, a)
        groupVector <- c(groupVector, grpID)
        eventVector <- c(eventVector, "lps9mo")
        dateVector <- c(dateVector, lps9Date)
      }
    }
    
    groupCompleteDate <- subset(clinicalPulls, phase == paste0("SGE",sgePhase) & groupID == grpID)$group_completion_date[1]
    
    #if the animal was pulled, do these things:
    if ( a %in% subset(clinicalPulls, phase == paste0("SGE",sgePhase))$Animal ) {
      animalPulls <- subset(clinicalPulls, Animal == a & phase == paste0("SGE",sgePhase))
    
      #modify plot end date in the case of euthanasia
      if ( "euthanized" %in% animalPulls$outformoreinfo ) {
        plotEndDate <- animalPulls$clinical_date_out[which(animalPulls$outformoreinfo == "euthanized")]
      }
      
      #create list of dates animal was absent
      for (r in 1:dim(animalPulls)[1]) {
        absentDates <- c(absentDates,
                         animalPulls$clinical_date_in[r]:animalPulls$clinical_date_out[r])
      }
    }
    
    for (d in groupCompleteDate:plotEndDate) {
      if ( d %in% absentDates ) {
        animalVector <- c(animalVector, a)
        groupVector <- c(groupVector, grpID)
        eventVector <- c(eventVector, "clinical")
        dateVector <- c(dateVector, d)
      } else {
        animalVector <- c(animalVector, a)
        groupVector <- c(groupVector, grpID)
        eventVector <- c(eventVector, "in")
        dateVector <- c(dateVector, d)
      }
    }
  }
  
  sge2dates <- as.data.frame(cbind(animalVector,groupVector,eventVector,dateVector))
  sge2dates$dateVector <- as.Date.numeric(as.numeric(sge2dates$dateVector))
  
  
  colnames(sge2dates) <- c("animal","group","event","date")
  
  animalGroups <- unique(sge2dates[,1:2])
  animalGroups <- animalGroups[order(animalGroups$group),]
  
  groupDates <- unique(subset(clinicalPulls, phase == paste0("SGE",sgePhase))[,2:3])
  
  #add group date to animal groups object
  animalGroups$date <- ""
  for (r in 1:dim(animalGroups)[1]) {
    #print(r)
    groupID <- animalGroups$group[r]
    groupDate <- groupDates$group_completion_date[which(groupDates$groupID == groupID)]
    animalGroups$date[r] <- groupDate
  }
  
  animalGroups <- animalGroups[order(animalGroups$date),]
  
  sge2dates$animal <- factor(sge2dates$animal, levels = animalGroups$animal)
  
  endDate <- max(subset(sge2dates, !event %in% c("in","clinical"))$date) + 60
  sge2plotDates <- subset(sge2dates, date < endDate)
  
  sge2plotDates$animalGroup <- paste0(sge2plotDates$animal,"-",sge2plotDates$group)
  sge2plotDates$animalGroup <- factor(sge2plotDates$animalGroup, levels = paste0(animalGroups$animal,"-",animalGroups$group))
  
  
  ggplot() +
    geom_point(aes(y = subset(sge2plotDates, event %in% c("in","clinical"))$animalGroup, 
                   x = subset(sge2plotDates, event %in% c("in","clinical"))$date, 
                   col = subset(sge2plotDates, event %in% c("in","clinical"))$event), size = 1) +
    geom_point(aes(y = subset(sge2plotDates, !event %in% c("in","clinical"))$animalGroup, 
                   x = subset(sge2plotDates, !event %in% c("in","clinical"))$date, 
                   col = subset(sge2plotDates, !event %in% c("in","clinical"))$event), size = 3) +
    scale_x_date(date_minor_breaks = "7 day", date_labels = "%b %Y") + labs(color = "event") +
    xlab("Date") + ylab("Animal") + theme(axis.text.y = element_text(size = 6))
  
  ggsave(paste0(figDir,"sge2phase",sgePhase,"_samplingAndclinical_datePlot.png"), 
         width = 8, height = 4)
  
  assign(value = sge2dates, x = paste0("sge2p",sgePhase,"dates"))
}
```


# Calculate Behavior Metric, Full & Partial Phase Data

sge.behavioralRateData.df.readme

Column descriptions for:
object = sge.behave.summary.full
file = sge2Behavior_shortCols_phase<1/2>_adj<SingleCell/Vax/EnvChall>.txt

ID - Individual ID, two-letter code
phase.agg - Phase of SGEII Experiment
group.agg - Individual's Group
intro.no - Order of introduction from intro_all
elo.agg - final elo from intro_all
num.obs - Total number of 30 min. observational period that the animal was recorded in
ordinal.rank - rank from the elo in intro_all
agg.received - count of agonisms received
id.group - column of ID_group
eloID - Individual two-letter ID
calcElo - Elo calculated from specified subset of data (pre-sample collection)
groupEloStab - group stability of calcElo (via eloRating)
groupEloDCI - group directional consistency (via eloRating)
elo.groom - Elo from intro_all
min - minutes of grooming total
min.give - minutes of grooming given
min.receive - minutes of grooming received
no.obs - Total number of 30 min. observational period that the animal was recorded in
group.groom - Individual's Group
phase.groom - Phase of SGEII Experiment
rawGroomRate - grooming minutes per hour; (groom.min/no.obs)*2
rawAggRecRate - aggression events received per hour; (agg.received.count/no.obs)*2
calcOrdRank - ordinal rank from calcElo (from specified subset of data, pre-sample collection)
experimentDate - date of the experiment for this animal
grpExpDate - date of the experiment for this animal's group, should be populated even if the animal wasn't sampled
adjDate - name of the experiment (SingleCell, Vaccine, etc)
fractionKept - fraction of group's behavioral observations that occurred before the experiment
animalID - full "R____" animal ID
groupStart - start date for the group, or the completion of introducing the animals
diedInPhase - TRUE/FALSE for this animal
daysOut - number of days spent in clinic only
fracTimeInGroup - total days spent IN the group / total time between group start and experiment
groupcent_groom - within group centered grooming rate
groupcent_agRec - within group centered rate of agonisms received
groupcent_elo - within group cenetered Elo
group.gc - Individual's Group
adjDate - experiment that data was generated for
fractionKept - fraction of full phase's observations used, fraction of observations taken before this experiment
animalID - Full animal ID (R__##, e.g. RAi10 where two-letter is AI)
experimentDate - date of sampling for this animal


```{r calculated behavioral data from raw}
### grooming, agonisms received, & elo

#example values
#check
#rowNum <- 3

# data frame of datasets to generate
dataCombos <- cbind.data.frame(c(FALSE,FALSE,TRUE,TRUE,TRUE,TRUE,TRUE),
                               c(1,2,1,1,1,2,2),
                               c("WholePhase","WholePhase","SingleCell","Vax","EnvChall","Vax","EnvChall"))

colnames(dataCombos) <- c("adjustData","sgePhase","samplingDate")

for (rowNum in 1:dim(dataCombos)[1]) {
  
  print(rowNum)
  
  adjustData <- dataCombos$adjustData[rowNum]
  samplingDate <- dataCombos$samplingDate[rowNum]
  sgePhase <- dataCombos$sgePhase[rowNum]

  #sge2dates <- get(x = paste0("sge2p",sgePhase,"dates"))
  if ( sgePhase == 1 ) {
    sge2dates <- sge2p1dates
  } else {
    sge2dates <- sge2p2dates
  }
  
  dir.create(paste0(figDir,"phase",sgePhase))
  dir.create(paste0(figDir,"phase",sgePhase,"/",samplingDate))
  dir.create(paste0(outDir,"phase",sgePhase))
  dir.create(paste0(outDir,"phase",sgePhase,"/",samplingDate))
  
  if (sgePhase == 1) {
    dateDF <- sampleDates[colnames(sampleDates) %in% c("animal","group",paste0("date",samplingDate))]
  } else {
    dateDF <- samplingDates[!is.na(samplingDates$groupP2),
                            which(colnames(samplingDates) %in% c("animal","groupP2"))]
    colnames(dateDF)[which(colnames(dateDF) == "groupP2")] <- "group"
    
    if (adjustData) {
      sampleDatesP2event <- subset(sampleDatesP2, event == samplingDate)
      groupDateDF <- sampleDatesP2event[colnames(sampleDatesP2event) %in% c("group","date")]
      
      dateDF$date <- ""
      
      for (g in unique(dateDF$group)) {
        dateDF$date[which(dateDF$group == g)] <- subset(groupDateDF, group == g)$date
      }
      
      colnames(dateDF)[which(colnames(dateDF) == "date")] <- paste0("date",samplingDate)
    }
  }
  
  if ( !adjustData ) {
     if (sgePhase == 1) {
       dateDF$date <- max(max(samplingDates[,4], na.rm = TRUE),
                           max(samplingDates[,5], na.rm = TRUE),
                           max(samplingDates[,6], na.rm = TRUE)) + 30
        } else {
          dateDF$date <- max(max(samplingDates[,8], na.rm = TRUE),
                             max(samplingDates[,9], na.rm = TRUE),
                             max(samplingDates[,10], na.rm = TRUE),
                             max(samplingDates[,11], na.rm = TRUE),
                             max(samplingDates[,12], na.rm = TRUE)) + 30
        }
    }
  
  dateDF[,3] <- as.Date(dateDF[,3])
  
  #add two letter code to dateDF
  #replace moonlight, drop leading "R", swap for uppers
  dateDF$twoLetter <- gsub('77_06', 'mo', dateDF$animal)
  dateDF$twoLetter <- gsub('^R', '', dateDF$twoLetter)
  dateDF$twoLetter <- toupper(substr(dateDF$twoLetter, start = 1, stop = 2))
  
  #NSPF4 + DJ --> D2
  if ( sgePhase == 2 ) {
    #there are 2 DJ's in phase 2, RDj7 in NSPF4 was labeled "D2" not "DJ"
    dateDF$twoLetter[which(dateDF$animal == "RDj7")] <- "D2"
  }
  
  dateDF$dateStart <- NA
  
  #add group start date
  for (grp in groupStart$Group) {
    grpRow <- which(groupStart$Group == grp)
    if (sgePhase == 1) {
      dateDF$dateStart[dateDF$group == grp] <- groupStart$Phase1Completion[grpRow]
    } else {
      dateDF$dateStart[dateDF$group == grp] <- groupStart$Phase2Completion[grpRow]
    }
  }
  
  dateDF$dateStart <- as.Date(dateDF$dateStart)
  
  #create an "_1" group column
  dateDF$group_1 <- paste0(dateDF$group,"_1")
  
  #mass calc Elo - if TRUE calculate animal Elo for all groups together
  massCalcElo <- FALSE
  
  if (sgePhase == 1) {
    phase_data <- data_list[names(data_list) %in% 
                              c("NSPF1_1","NSPF2_1","NSPF3_1","NSPF4_1","NSPF5_1",
                                "SPF1_1","SPF2_1","SPF3_1","SPF4_1","SPF5_1")]
    intro_phase <- subset(intro_all, phase == "SGE1")
  } else {
    phase_data <- data_list[names(data_list) %in% 
                              c("NSPF1","NSPF2","NSPF3","NSPF4","NSPF5",
                                "SPF1","SPF2","SPF3","SPF4","SPF5")]
    intro_phase <- subset(intro_all, phase == "SGE2")
  }

  social <- lapply(phase_data,convert.soc)
  dominance <- lapply(phase_data,convert.dom.git)
  
  #single animal was not in intro_all phase 2, exists in behavior data
  if (sgePhase == 2) {
    intro_phase <- rbind(intro_phase,c("Sd4","SGE2","SPF1",5,500,1,5))
    intro_phase$intro.no <- as.numeric(intro_phase$intro.no)
    intro_phase$elo <- as.numeric(intro_phase$elo)
    intro_phase$num.obs <- as.numeric(intro_phase$num.obs)
    intro_phase$ordinal.rank <- as.numeric(intro_phase$ordinal.rank)
    intro_phase <- intro_phase[order(intro_phase$group),]
    rownames(intro_phase) <- as.character(1:dim(intro_phase)[1])
  }
  
  ### This code allows for the dates to be modified, to end observations at the time of sampling
  if ( adjustData == TRUE) {
    
    dateDF$fracKept <- 0
    g <- names(dominance)[2]
    
    for (g in names(dominance)) {
      
      if (sgePhase == 1) {
        d <- sort(unique(subset(dateDF, group_1 == g)[,3]))[1]
      } else {
        d <- sort(unique(subset(dateDF, group == g)[,3]))[1]
      }
      
      fractionKept <- mean(social[which(names(social) == g)][[1]]$Date < d)
      dataToKeep <- social[which(names(social) == g)][[1]]$Date < d
      domToKeep <- dominance[which(names(dominance) == g)][[1]]$Date < d
      
      if (sgePhase == 1) {
        dateDF$fracKept[which(dateDF$group_1 == g)] <- fractionKept
      } else {
        dateDF$fracKept[which(dateDF$group == g)] <- fractionKept
      }
      
      social[which(names(social) == g)][[1]] <- social[which(names(social) == g)][[1]][dataToKeep,]
      dominance[which(names(dominance) == g)][[1]] <- dominance[which(names(dominance) == g)][[1]][domToKeep,]
    }
  }

  groom <- lapply(social,function(x){x[which(x[,5]%in%c("GM","G-","ZZ")),]})
  aggs <- prox <- lapply(social,function(x){x[which(x[,5]%in%c("TN","TC","AT","CH")),]})
  agg.received <- lapply(aggs,function(x){aggregate(x[,4],by=list(x[,4]),length)})

  if ( adjustData == TRUE ) {
    dateDF$numObs <- 0
    dateDF <- dateDF[order(dateDF$group),]
    
    for (g in names(dominance)) {
      if (sgePhase == 1) {
        gIDs <- which(dateDF$group_1 == g)
      } else {
        gIDs <- which(dateDF$group == g)
      }
      
      newObs <- length(unique(social[[which(names(social) == g)]]$Date))
      
      dateDF$numObs[gIDs] <- newObs
    }
    
  } else {
    dateDF <- dateDF[order(dateDF$group),]
  }

  group <- vector()
  ID1 <- vector()
  ID2 <- vector()
  count <- 1

  for (i in unique(intro_phase$group)) {
    id1 <- unique(subset(intro_phase, group == i)$ID)
    for (j in id1){
      for (k in id1){
        if (j != k){
          ID1[count] <- j
          ID2[count] <- k
          group[count] <- i
          count <- count + 1
        }
      }
    }
  }
  
  ## calculate grooming
  groom.tot <- data.frame(matrix(ncol=17,nrow=length(ID1)))
  groom.tot$X1 <- ID1
  groom.tot$X2 <- ID2
  groom.tot$X3 <- group
  colnames(groom.tot) <- c("ID1","ID2","group","no.obs","bouts","ID1.groom",
                           "ID2.groom","min","ID1.groom.min","ID2.groom.min",
                           "ID1.rank","ID2.rank","ID1.ord.rank","ID2.ord.rank",
                           "agg.bouts","ID1.agg","ID2.agg")
  
  # change IDs to short, uppercase IDs
  groom.tot[,1] <- as.character(groom.tot[,1]); 
  groom.tot[,2] <- as.character(groom.tot[,2]); 
  groom.tot[,3] <- as.character(groom.tot[,3])
  groom.tot$ID1 <- toupper(substr(groom.tot$ID1, 1,2))
  groom.tot$ID2 <- toupper(substr(groom.tot$ID2, 1,2))
  groom.tot$ID1 <- gsub('77','MO',groom.tot$ID1)
  groom.tot$ID2 <- gsub('77','MO',groom.tot$ID2)
  intro_phase$ID <- toupper((substr(intro_phase$ID, 1,2)))
  
  ##caclulate grooming bouts
  for (id in 1:nrow(groom.tot)){
    id1 <- groom.tot[id,"ID1"]; id2<-groom.tot[id,"ID2"]; 
    g <- groom[[as.character(groom.tot[id,"group"])]]; 
    b1=0;b2=0;grp<-groom.tot[id,"group"]
    b1=sum(g[,5]=="GM"&g[,3]==id1 & g[,4]==id2)
    b2=sum(g[,5]=="GM"&g[,4]==id1 & g[,3]==id2)
    groom.tot[id,5]=b1+b2;groom.tot[id,6]=b1;groom.tot[id,7]=b2
    groom.tot[id,4]=intro_phase[which(intro_phase[,"ID"]==id1&intro_phase$group==grp),"num.obs"]
    groom.tot[id,"ID1.rank"]=intro_phase[which(intro_phase[,"ID"]==id1&intro_phase$group==grp),"elo"]
    groom.tot[id,"ID2.rank"]=intro_phase[which(intro_phase[,"ID"]==id2&intro_phase$group==grp),"elo"]
    groom.tot[id,"ID1.ord.rank"]=intro_phase[which(intro_phase[,"ID"]==id1&intro_phase$group==grp),"ordinal.rank"]
    groom.tot[id,"ID2.ord.rank"]=intro_phase[which(intro_phase[,"ID"]==id2&intro_phase$group==grp),"ordinal.rank"]
  }  
  
  ## calculate grooming times
  #groom.tot$ID1.groom.min <- NA
  #groom.tot$ID2.groom.min <- NA
  #groom.tot$min <- NA
  ## swapping NA for 0, because of SD with low observations
  groom.tot$ID1.groom.min <- 0
  groom.tot$ID2.groom.min <- 0
  groom.tot$min <- 0
    
  for (i in 1:nrow(groom.tot)){
    id1 <- groom.tot[i,"ID1"]
    id2 <- groom.tot[i,"ID2"]
    t1=0
    t2=0
    g <- groom[[as.character(groom.tot[i,"group"])]]
    if (id1%in%c(g[,3],g[,4])&id2%in%c(g[,3],g[,4])){
      g<-g[which((g[,4]==id1 & g[,3]==id2 )|(g[,3]==id1 & g[,4]==id2)|g[,3]=="ZZ"),]
      for (r in 1:nrow(g)){
        if (g[r,5]=="GM" & g[r,3]==id1 & g[r,4]==id2) t1=t1+(g[r+1,2]-g[r,2])
        if (g[r,5]=="GM" & g[r,4]==id1 & g[r,3]==id2) t2=t2+(g[r+1,2]-g[r,2])
      }
      groom.tot[i,"ID1.groom.min"]=t1
      groom.tot[i,"ID2.groom.min"]=t2
      groom.tot[i,"min"]=t1+t2}
  }
  rm(t1);rm(t2);rm(i);rm(id1);rm(id2);rm(r);rm(g)
  
  # add phase info
  groom.tot$phase <- sgePhase
  
  tmp.minutes <- vector()
  tmp.minutes.give <- vector()
  tmp.minutes.receive <- vector()
  tmp.names <- vector()
  tmp.ranks <- vector()
  tmp.obs <- vector()
  tmp.group <- vector()
  
  for (i in unique(groom.tot$ID1)){
    tmp <- subset(groom.tot, groom.tot$phase == sgePhase)
    tmp2 <- sum(subset(tmp, tmp$ID1 == i)$min)
    tmp3 <- sum(subset(tmp, tmp$ID1 == i)$ID1.groom.min)
    tmp4 <- tmp2 - tmp3
    tmp.minutes <- cbind(tmp.minutes,tmp2)
    tmp.minutes.give <- cbind(tmp.minutes.give,tmp3)
    tmp.minutes.receive <- cbind(tmp.minutes.receive,tmp4)
    tmp.names <- cbind(tmp.names,i)
    tmp.ranks <- cbind(tmp.ranks,subset(tmp, tmp$ID1 == i)$ID1.rank[1])
    tmp.obs <- cbind(tmp.obs,subset(tmp, tmp$ID1 == i)$no.obs[1])
    tmp.group <- cbind(tmp.group,subset(tmp, tmp$ID1 == i)$group[1])
  }  
  
  sge.groom.rate.df <- as.data.frame(t(rbind(tmp.names,tmp.ranks,tmp.minutes,tmp.minutes.give,tmp.minutes.receive,tmp.obs,tmp.group)))
  names(sge.groom.rate.df) <- c('ID','elo','min','min.give','min.receive','no.obs','group')
  sge.groom.rate.df <- na.omit(sge.groom.rate.df)
  sge.groom.rate.df$elo <- as.numeric(as.character(sge.groom.rate.df$elo))
  sge.groom.rate.df$min <- as.numeric(as.character(sge.groom.rate.df$min))
  sge.groom.rate.df$min.give <- as.numeric(as.character(sge.groom.rate.df$min.give))
  sge.groom.rate.df$min.receive <- as.numeric(as.character(sge.groom.rate.df$min.receive))
  sge.groom.rate.df$no.obs <- as.numeric(as.character(sge.groom.rate.df$no.obs))
  sge.groom.rate.df$phase <- sgePhase
  
  ### Agonisms Received
  agg <- vector()
  name <- vector()
  group <- vector()
  
  for (i in unique(intro_phase$group)){
    tmp3 <- agg.received[[i]]$Group.1
    tmp4 <- agg.received[[i]]$x
    tmp5 <- rep(i,length(tmp3))
    agg <- c(agg,tmp4)
    name <- c(name,tmp3)
    group <- c(group,tmp5)
  }
  
  tmp <- as.data.frame(cbind(agg,name,group))
  tmp <- tmp[!(tmp$name=="ZZ"),]
  tmp$agg <- as.numeric(as.character(tmp$agg))
  tmp$name <- toupper(tmp$name)
  tmp$id.group <- paste(tmp$name,tmp$group, sep='_')
  
  intro_sub <- intro_phase
  intro_sub$agg.received <- 0
  intro_sub$id.group <- paste(intro_sub$ID,intro_sub$group, sep='_')
  tmp <- subset(tmp, tmp$id.group %in% intro_sub$id.group)
  intro_sub <- subset(intro_sub, intro_sub$id.group %in% tmp$id.group)
  intro_sub <- intro_sub[match(tmp$id.group, intro_sub$id.group),]
  intro_sub <- na.omit(intro_sub)
  intro_sub$agg.received <- tmp$agg
  
  intro_phase$id.group <- paste(intro_phase$ID,intro_phase$group, sep='_')
  tmp <- subset(intro_phase, !(intro_phase$id.group %in% intro_sub$id.group))
  tmp$agg.received <- 0
  intro_sub <- rbind.data.frame(intro_sub,tmp)
  ####
  
  
  ### Elo Function
  intro_sub$eloID <- ""
  intro_sub$calcElo <- 0
  intro_sub$eloIDStart <- ""
  intro_sub$calcEloStart <- 0
  intro_sub$groupEloStab <- 0
  intro_sub$groupEloDCI <- 0
  
  ### Repeat For Each Group
  groupIDs <- names(dominance)
  g <- groupIDs[2]
  
  if (massCalcElo == TRUE) {
    domAll <- do.call(rbind.data.frame, dominance)
    
    domAll <- domAll[order(domAll$Date),]

    #only distinct interactions
    domAllElo <- subset(domAll, Winner != Loser)
    elo <- elo.seq(domAllElo$Winner,domAllElo$Loser,domAllElo$Date)
    eloVals <- extract_elo(elo)
    names(eloVals) <- toupper(names(eloVals))
    
  } else {
  
    for (g in groupIDs) {
      groupNum <- which(groupIDs == g)
      groupDom <- as.data.frame(dominance[groupNum])
      
  
      colnames(groupDom) <- c("Date","Time","Winner","Loser")
      
      groupDom <- groupDom[order(groupDom$Date),]
      
      #only distinct interactions
      groupDomElo <- subset(groupDom, Winner != Loser) |> 
                        dplyr::filter(Winner != "oo") |>
                        dplyr::filter(Winner != "H%")
      elo <- elo.seq(groupDomElo$Winner,groupDomElo$Loser,groupDomElo$Date)
      eloVals <- extract_elo(elo)
      names(eloVals) <- toupper(names(eloVals))
      
      #pull start date
      g_only <- gsub("_.*", "", g)
      stDate <- dateDF |> dplyr::filter(group == g_only) |> dplyr::pull(dateStart) |> max()
      
      #starting Elo, either "start" or first 3 obs, whichever is longer
      #by date
      groupDomEloStartDate <- groupDomElo |> dplyr::filter(Date <= stDate)
      #by n obs
      firstThree <- groupDomElo |> dplyr::group_by(Date) |> dplyr::pull(Date) |> unique() |> head(n=3)
      groupDomEloStartObs <- groupDomElo |> dplyr::filter(Date %in% firstThree)
      
      if (nrow(groupDomEloStartDate) >= nrow(groupDomEloStartObs)) {
        groupDomEloStart <- groupDomEloStartDate
      } else {
        groupDomEloStart <- groupDomEloStartObs
      }
      
      eloStart <- elo.seq(groupDomEloStart$Winner, groupDomEloStart$Loser, groupDomEloStart$Date)
      eloValStart <- extract_elo(eloStart)
      names(eloValStart) <- toupper(names(eloValStart))
      
      
      groupStab <- stab_elo(elo)
      
      dciMat <- creatematrix(eloobject = elo,daterange = NULL,drawmethod = "omit",onlyinteracting = FALSE,draw = NULL)
      groupDCI <- DCindex(dciMat)
      
      intro_sub$groupEloStab[which(intro_sub$group == g)] <- groupStab
      intro_sub$groupEloDCI[which(intro_sub$group == g)] <- groupDCI
      
      for (i in names(eloVals)) {
        eloNum <- which(names(eloVals) == i)
        intro_sub$calcElo[which(intro_sub$ID == i)] <- eloVals[eloNum]
        intro_sub$eloID[which(intro_sub$ID == i)] <- names(eloVals)[eloNum]
        
        if (i %in% names(eloValStart)) {
        eloNumStart <- which(names(eloValStart) == i)
        intro_sub$calcEloStart[which(intro_sub$ID == i)] <- eloValStart[eloNumStart]
        intro_sub$eloIDStart[which(intro_sub$ID == i)] <- names(eloValStart)[eloNumStart]
        } else {
        intro_sub$calcEloStart[which(intro_sub$ID == i)] <- 1000
        intro_sub$eloIDStart[which(intro_sub$ID == i)] <- i
        }
      }
    }
  }
  
  elo_start_stop_R <- cor.test(intro_sub$calcElo, intro_sub$calcEloStart)$estimate
  elo_start_stop_p <- cor.test(intro_sub$calcElo, intro_sub$calcEloStart)$p.value

  
  ### Combine and Output Data
  sge.behave.summary <- merge(intro_sub,
                              sge.groom.rate.df, 
                              by = "ID",
                              suffixes = c(".agg",".groom"))
  
  
  sge.behave.summary$rawGroomRate <- (sge.behave.summary$min / sge.behave.summary$num.obs ) * 2
  sge.behave.summary$rawAggRecRate <- (sge.behave.summary$agg.received / sge.behave.summary$num.obs ) * 2
  
  #get ordinal rank
  sge.behave.summary$calcOrdRank <- 0
  for (g in groupIDs) {
    groupOrdRank <- rank(-subset(sge.behave.summary, group.agg == g)$calcElo)
    sge.behave.summary$calcOrdRank[which(sge.behave.summary$group.agg == g)] <- groupOrdRank
  }
  
  # R of order of intro ~ order of Elo
  rIntroElo <- cor.test(sge.behave.summary$calcElo, sge.behave.summary$intro.no)$estimate
  # p of order of intro ~ order of Elo
  pIntroElo <- cor.test(sge.behave.summary$calcElo, sge.behave.summary$intro.no)$p.value
  
  ggplot(data = sge.behave.summary,
         aes(x = intro.no,
             y = calcElo)) +
    geom_smooth(method = "lm", formula = "y~x", se = FALSE, lwd = .5, col = "black") +
    geom_jitter(aes(col = group.agg), size = 3, height = .1, width = .1) +
    labs(col = "Group") +
    xlab("Order of Introduction") + ylab("Dominance Rank (Elo)") +
    ggtitle(paste0("Dominance Rank v. Introduction Order, ",samplingDate," SGEII Phase ",sgePhase),
            subtitle = paste0("R = ",signif(rIntroElo, digits = 3)," | p = ",signif(pIntroElo, digits = 3)))
  ggsave(paste0(figDir,"phase",sgePhase,"/",samplingDate,"/","sge2phase",sgePhase,"_",samplingDate,"_EloRank_v_IntroOrder_XYplot.png"),
         width = 6, height = 4)
  
  #add experiment date
  sge.behave.summary$experimentDate <- NA
  #date the group was sampled
  sge.behave.summary$grpExpDate <- NA
  
  if (adjustData) {
    for (anID in sge.behave.summary$ID) {
      if (anID %in% dateDF$twoLetter) {
        groupID <- subset(dateDF, twoLetter == anID)$group
        sge.behave.summary$experimentDate[which(sge.behave.summary$ID == anID)] <- subset(dateDF, twoLetter == anID)[,3]
        sge.behave.summary$grpExpDate[which(sge.behave.summary$ID == anID)] <- unique(sort(subset(dateDF, group == groupID)[,3]))[1]
      }
    }
  } else {
    sge.behave.summary$grpExpDate <- dateDF$date[1]
  }
  
  sge.behave.summary$experimentDate <- as.Date(sge.behave.summary$experimentDate)
  sge.behave.summary$grpExpDate <- as.Date(sge.behave.summary$grpExpDate)

  
  #add fraction kept to sge behave
  sge.behave.summary$adjDate <- samplingDate
  
  sge.behave.summary$fractionKept <- NA
  sge.behave.summary$animalID <- ""
  
  sge.behave.summary$groupStart <- as.Date(NA)
  sge.behave.summary$diedInPhase <- FALSE
  sge.behave.summary$daysOut <- 0
  sge.behave.summary$fracTimeInGroup <- 0
  
  #i <- sge.behave.summary$ID[7]
  
  for (i in sge.behave.summary$ID) {
    
    #print(i)
    if (i %in% dateDF$twoLetter) {
      dfDateRow <- which(dateDF$twoLetter == i)
      behaveRow <- which(sge.behave.summary$ID == i)
      

      sge.behave.summary$animalID[behaveRow] <- dateDF$animal[dfDateRow]
      sge.behave.summary$groupStart[behaveRow] <- dateDF$dateStart[dfDateRow]
      sge.behave.summary$groupStart[behaveRow] <- as.Date(sge.behave.summary$groupStart[behaveRow])
      
      if (subset(clinicInfo, Phase == paste0("SGE",sgePhase) & 
                             Animal == sge.behave.summary$animalID[behaveRow])$Death == "yes") {
        sge.behave.summary$diedInPhase[behaveRow] <- TRUE
      }
      
      #doublecheck that the sge2 dates were loaded correctly, if not, reload them
      #this term is checking that the animal's first day in the group matches the group's first date, if not it reloads sge2dates
      if ( !head(subset(sge2dates, animal == sge.behave.summary$animalID[behaveRow] & event == "in"), n = 1)$date == sge.behave.summary$groupStart[behaveRow] ) {
        sge2dates <- get(x = paste0("sge2p",sgePhase,"dates"))
      }

      
      #check sge2dates for exact days out
      daysIn <- dim(subset(sge2dates, animal == sge.behave.summary$animalID[behaveRow] & 
                                      date < sge.behave.summary$grpExpDate[behaveRow] & 
                                      event == "in"))[1]
      daysOut <- dim(subset(sge2dates, animal == sge.behave.summary$animalID[behaveRow] & 
                                      date < sge.behave.summary$grpExpDate[behaveRow] & 
                                      event == "clinical"))[1]
      
      totDays <- as.numeric(sge.behave.summary$grpExpDate[behaveRow] - sge.behave.summary$groupStart[behaveRow])
      
      sge.behave.summary$daysOut[behaveRow] <- daysOut
      sge.behave.summary$fracTimeInGroup[behaveRow] <- daysIn / totDays
      
      if (adjustData == FALSE) {
        sge.behave.summary$fractionKept[behaveRow] <- 1
      } else {
        sge.behave.summary$fractionKept[behaveRow] <- dateDF$fracKept[dfDateRow]
      }
    }
  }
  
  # number of animals (in behavior measure)
  numAnimals <- dim(sge.behave.summary)[1]
  # number of animals (in behavior measure, without DV2J)
  numAnimalsNoDV2J <- dim(sge.behave.summary)[1] - 1
  
  #save data before dropping animals
  write.table(x = sge.behave.summary,
              file = paste0(outDir,"phase",sgePhase,"/",samplingDate,"/","sge2Behavior_phase",sgePhase,"_adj",samplingDate,"_allAnimals.txt"),
              quote = FALSE, 
              sep = ",")
  #r objects
  saveRDS(object = sge.behave.summary,
              file = paste0(outDir,"phase",sgePhase,"/",samplingDate,"/","sge2Behavior_phase",sgePhase,"_adj",samplingDate,"_allAnimals.RDS"))
  
  #drop DV2J
  sge.behave.summary <- subset(sge.behave.summary, ID != "DV")
  #individuals who were in the group more than 50% of the time (fractTimeInGroup >= .5) are kept for centering, others dropped
  sge.behave.summary <- subset(sge.behave.summary, fracTimeInGroup >= .5)
  
  sge.behave.summary$groupcent_groom <- 0
  sge.behave.summary$groupcent_agRec <- 0
  sge.behave.summary$groupcent_elo <- 0
  sge.behave.summary$group.gc <- ""
  
  behaveCols <- which(colnames(sge.behave.summary) %in% c("ID",
                                                  "rawGroomRate",
                                                  "rawAggRecRate",
                                                  "calcElo"))
  
  #group center behavior rates
  for (g in sort(unique(sge.behave.summary$group.agg))) {
    #print(g)
    groupBehave <- subset(sge.behave.summary, group.agg == g)[,behaveCols]
    
    newGroom <- scale(groupBehave[,3], center = TRUE, scale = FALSE)
    newAgRec <- scale(groupBehave[,4], center = TRUE, scale = FALSE)
    newElo <- scale(groupBehave[,2], center = TRUE, scale = FALSE)
    
    groupBehave$groupcent_elo <- newElo
    groupBehave$groupcent_groom <- newGroom
    groupBehave$groupcent_agRec <- newAgRec
    
    for (i in groupBehave$ID) {
      sge.behave.summary$group.gc[which(sge.behave.summary$ID == i)] <- g
      
      sge.behave.summary$groupcent_elo[which(sge.behave.summary$ID == i)] <- groupBehave$groupcent_elo[which(groupBehave$ID == i)]
      sge.behave.summary$groupcent_groom[which(sge.behave.summary$ID == i)] <- groupBehave$groupcent_groom[which(groupBehave$ID == i)]
      sge.behave.summary$groupcent_agRec[which(sge.behave.summary$ID == i)] <- groupBehave$groupcent_agRec[which(groupBehave$ID == i)]
    }
  }
  
  ## cut down columns to minimum metadata (just raw behaviors, group centered behaviors, and animal/group ID)
  sge.behave.summary.full <- sge.behave.summary
  sge.behave.summary <- sge.behave.summary[,colnames(sge.behave.summary) %in% c("ID",
                                                                                "phase.agg",
                                                                                "group.agg",
                                                                                "rawGroomRate",
                                                                                "rawAggRecRate",
                                                                                "calcElo",
                                                                                "groupcent_groom",
                                                                                "groupcent_agRec",
                                                                                "groupcent_elo",
                                                                                "adjDate",
                                                                                "fractionKept",
                                                                                "animalID",
                                                                                "experimentDate")]
  
  colnames(sge.behave.summary)[which(colnames(sge.behave.summary) == "phase.agg")] <- "phase"
  colnames(sge.behave.summary)[which(colnames(sge.behave.summary) == "group.agg")] <- "group"
  
  #correlations between metrics
  ## Elo - AgRec
  # R 
  rMetCorr <- cor.test(sge.behave.summary$groupcent_agRec, sge.behave.summary$groupcent_elo)$estimate
  # p 
  pMetCorr <- cor.test(sge.behave.summary$groupcent_agRec, sge.behave.summary$groupcent_elo)$p.value
  
  ggplot(data = sge.behave.summary,
         aes(y = groupcent_agRec,
             x = groupcent_elo)) +
    geom_smooth(method = "lm", formula = "y~x", se = FALSE, lwd = .5, col = "black") +
    geom_jitter(aes(col = group), size = 3, height = .1, width = .1) +
    labs(col = "Group") +
    xlab("Group-Centered Elo") + ylab("Group-Centered AgRec") +
    ggtitle(paste0("Group-Centered AgRec v. Group-Centered Elo, ",samplingDate," SGEII Phase ",sgePhase),
            subtitle = paste0("R = ",signif(rMetCorr, digits = 3)," | p = ",signif(pMetCorr, digits = 3)))
  ggsave(paste0(figDir,"phase",sgePhase,"/",samplingDate,"/","sge2phase",sgePhase,"_",samplingDate,"_gcAgRec_v_gcElo_XYplot.png"),
         width = 6, height = 4)

  ## Elo - Groom
  # R 
  rMetCorr <- cor.test(sge.behave.summary$groupcent_groom, sge.behave.summary$groupcent_elo)$estimate
  # p 
  pMetCorr <- cor.test(sge.behave.summary$groupcent_groom, sge.behave.summary$groupcent_elo)$p.value
  
  ggplot(data = sge.behave.summary,
         aes(y = groupcent_groom,
             x = groupcent_elo)) +
    geom_smooth(method = "lm", formula = "y~x", se = FALSE, lwd = .5, col = "black") +
    geom_jitter(aes(col = group), size = 3, height = .1, width = .1) +
    labs(col = "Group") +
    xlab("Group-Centered Elo") + ylab("Group-Centered Groom") +
    ggtitle(paste0("Group-Centered Groom v. Group-Centered Elo, ",samplingDate," SGEII Phase ",sgePhase),
            subtitle = paste0("R = ",signif(rMetCorr, digits = 3)," | p = ",signif(pMetCorr, digits = 3)))
  ggsave(paste0(figDir,"phase",sgePhase,"/",samplingDate,"/","sge2phase",sgePhase,"_",samplingDate,"_gcGroom_v_gcElo_XYplot.png"),
         width = 6, height = 4)

  ## AgRec - Groom
  # R 
  rMetCorr <- cor.test(sge.behave.summary$groupcent_groom, sge.behave.summary$groupcent_agRec)$estimate
  # p 
  pMetCorr <- cor.test(sge.behave.summary$groupcent_groom, sge.behave.summary$groupcent_agRec)$p.value
  
  ggplot(data = sge.behave.summary,
         aes(y = groupcent_groom,
             x = groupcent_agRec)) +
    geom_smooth(method = "lm", formula = "y~x", se = FALSE, lwd = .5, col = "black") +
    geom_jitter(aes(col = group), size = 3, height = .1, width = .1) +
    labs(col = "Group") +
    xlab("Group-Centered AgRec") + ylab("Group-Centered Groom") +
    ggtitle(paste0("Group-Centered Groom v. Group-Centered AgRec, ",samplingDate," SGEII Phase ",sgePhase),
            subtitle = paste0("R = ",signif(rMetCorr, digits = 3)," | p = ",signif(pMetCorr, digits = 3)))
  ggsave(paste0(figDir,"phase",sgePhase,"/",samplingDate,"/","sge2phase",sgePhase,"_",samplingDate,"_gcGroom_v_gcAgRec_XYplot.png"),
         width = 6, height = 4)
  
  ## Generate filler text for methods section:
  # total observation hours for each group
  groupIDs <- unique(sge.behave.summary.full$group.agg)
  groupObs <- vector()
  #get the number of observation periods for each group
  
  for (g in groupIDs) {
    #groupObs <- c(groupObs,max(subset(sge.behave.summary.full, group.agg == g)$num.obs))
    if (sgePhase == 1) {
      groupObs <- c(groupObs,max(subset(dateDF, group_1 == g)$numObs))
    } else {
      groupObs <- c(groupObs,max(subset(dateDF, group == g)$numObs))
    }
  }
  #an observation period is 30 mins, so the total hours of obs = sum(group obs periods) / 2
  obsHours <- sum(groupObs) / 2
  # number of groups
  numGroups <- length(unique(sge.behave.summary.full$group.agg))
  # number of animals (in group centering)
  numAnimalsGC <- length(unique(sge.behave.summary.full$animalID))
  
  stabDF <- unique(sge.behave.summary.full[,colnames(sge.behave.summary.full) %in% c("groupEloStab","group.agg")])
  # average Stability
  meanStab <- mean(stabDF$groupEloStab)
  # stdev stability
  sdStab <- sd(stabDF$groupEloStab)
  
  dciDF <- unique(sge.behave.summary.full[,colnames(sge.behave.summary.full) %in% c("groupEloDCI","group.agg")])
  # average directional consistency
  meanDCI <- mean(dciDF$groupEloDCI)
  # stdev directional consistency
  sdDCI <- sd(dciDF$groupEloDCI)

  
  ### Oct 2025 updates
  ### use groom.tot to do a t-test of grooming up or down the hierarchy
  #ID1 Groom Min is grooming of ID1 -> ID2
  #step 1 is drop the 1's and 5's
  groom_ttest <- groom.tot |>
    dplyr::filter(ID1.ord.rank %in% c(2,3,4)) |>
    dplyr::mutate(groom_dir = ifelse(ID1.ord.rank > ID2.ord.rank, "up", "down")) |>
    dplyr::group_by(ID1, groom_dir) |>
    dplyr::summarize(tot_min = sum(min)) |>
    pivot_wider(names_from = groom_dir, 
              values_from = tot_min) %>%
  {t.test(.$up, .$down, paired = TRUE)}
  
  groom_by_up_down <- groom.tot |>
    dplyr::filter(ID1.ord.rank %in% c(2,3,4)) |>
    dplyr::mutate(groom_dir = ifelse(ID1.ord.rank > ID2.ord.rank, "up", "down")) |>
    dplyr::group_by(ID1, groom_dir) |>
    dplyr::summarize(tot_min = sum(min)) |>
    pivot_wider(names_from = groom_dir, 
              values_from = tot_min)
  
  mean(groom_by_up_down$down, na.rm = T)
  mean(groom_by_up_down$up, na.rm = T)
  
  ### test the grooming of adjacent animals
  groom.tot$group <- as.factor(groom.tot$group)
  # Prepare the data
  groom.tot <- groom.tot %>%
    mutate(
      # Calculate rank disparity (absolute difference in ranks)
      rank_disparity = abs(ID1.ord.rank - ID2.ord.rank),
      
      # Test 1: Binary outcome - did they groom at all?
      groomed_binary = ifelse(bouts > 0, 1, 0),
      
      # Test 2: Proportion of total grooming time
      # First calculate total grooming time across all dyads for each individual
      # This is a bit complex - we'll do it in steps below
    )
  
  # For Test 2, we need to calculate the proportion of grooming time
  # Option 1: Proportion within this specific dyad (simpler interpretation)
  groom.tot <- groom.tot %>%
  group_by(ID1) %>%
  mutate(
    total_ID1_groom_min = sum(ID1.groom.min, na.rm = TRUE),
    prop_groom = ifelse(total_ID1_groom_min > 0, 
                        ID1.groom.min / total_ID1_groom_min, 
                        0)
  ) %>%
  ungroup()
  
  # TEST 1: Logistic regression for binary grooming (groomed vs never groomed)
  model1 <- glm(groomed_binary ~ rank_disparity + group, 
                data = groom.tot, 
                family = binomial(link = "logit"))
  
  summary(model1)
  
  # To get Z-statistic and p-value specifically for rank_disparity:
  coef_summary1 <- summary(model1)$coefficients
  print(coef_summary1["rank_disparity", ])
  beta_rank_disp <- coef_summary1[2,1]
  z_rank_disp <- coef_summary1[2,3]
  p_rank_disp <- coef_summary1[2,4] 
  
  
  # TEST 2: Linear model for proportion of grooming time
  df_groomed <- groom.tot %>% filter(groomed_binary == 1)
  
  # Linear model with group as fixed effect
  model2 <- lm(prop_groom ~ rank_disparity + group, 
               data = df_groomed)
  
  summary(model2)
  
  # To get t-statistic and p-value specifically for rank_disparity:
  coef_summary2 <- summary(model2)$coefficients
  print(coef_summary2["rank_disparity", ])
  beta_rank_disp_proptime <- coef_summary2[2,1]
  z_rank_disp_proptime <- coef_summary2[2,3]
  p_rank_disp_proptime <- coef_summary2[2,4] 
  
  
    
  #generate output
  ## text files
  write.table(x = sge.behave.summary.full,
              file = paste0(outDir,"phase",sgePhase,"/",samplingDate,"/","sge2Behavior_phase",sgePhase,"_adj",samplingDate,".txt"),
              quote = FALSE, 
              sep = ",")
  write.table(x = sge.behave.summary,
              file = paste0(outDir,"phase",sgePhase,"/",samplingDate,"/","sge2Behavior_shortCols_phase",sgePhase,"_adj",samplingDate,".txt"),
              quote = FALSE, 
              sep = ",")
  #r objects
  saveRDS(object = sge.behave.summary.full,
              file = paste0(outDir,"phase",sgePhase,"/",samplingDate,"/","sge2Behavior_phase",sgePhase,"_adj",samplingDate,".RDS"))
  saveRDS(object = sge.behave.summary,
              file = paste0(outDir,"phase",sgePhase,"/",samplingDate,"/","sge2Behavior_shortCols_phase",sgePhase,"_adj",samplingDate,".RDS"))

  
  methodsOut <- file(paste0(outDir,"phase",sgePhase,"/",samplingDate,"/","sge2Behavior_phase",sgePhase,"_adj",samplingDate,"_methods.txt"))
  writeLines(c(paste0("SGEII Phase ",sgePhase),
               paste0("Sample Date: ",samplingDate),
               paste0("Observation Hours: ",obsHours),
               paste0("animals = ",numAnimals),
               paste0("animals w/o DV2J = ",numAnimalsNoDV2J),
               paste0("animals in Group Centering = ",numAnimalsGC),
               paste0("Ordinal Rank ~ Introduction Number: R = ",rIntroElo),
               paste0("Ordinal Rank ~ Introduction Number: p = ",pIntroElo),
               paste0("Mean Group Stability = ",meanStab),
               paste0("StDev Group Stability = ",sdStab),
               paste0("Mean Group Directional Consistency = ",meanDCI),
               paste0("StDev Group Directional Consistency = ",sdDCI)),
               paste0("Starting Elo ~ Ending Elo: R = ",elo_start_stop_R),
               paste0("Starting Elo ~ Ending Elo: p = ",elo_start_stop_p),
               paste0("Average Time Grooming 'Down' (dropping 1's and 5's) = ",mean(groom_by_up_down$down, na.rm = T)),
               paste0("Average Time Grooming 'Up' (dropping 1's and 5's) = ",mean(groom_by_up_down$up, na.rm = T)),
               paste0("Paired Grooming T-Test (Up - Down, positive means more grooming 'Up'): t = ",groom_ttest$statistic),
               paste0("Paired Grooming T-Test: p = ",groom_ttest$p.value),
               paste0("we tested if females who were adjacent in rank were more likely to groom together. for a binary pattern (groomed at all versus never groomed:",
                      "βrank_disparity = ",beta_rank_disp,
                      ",  Z = ",z_rank_disp,",  N = ",nrow(groom.tot)," dyads,",
                      "P = ",p_rank_disp,"), or the proportion of total grooming time that a female invested in a grooming partner, pGroom total,",
                      "in those dyads that groomed at least once (βrank_disparity = ",beta_rank_disp_proptime,", N = ",nrow(df_groomed)," dyads,",
                      "P = ",p_rank_disp_proptime),
               methodsOut)
  close(methodsOut)
}
```

### Correlations between partial and full data

```{r}

adjDataCombos <- subset(dataCombos, adjustData)
rowNum <- 1

groupByGroup <- data.frame()

for (rowNum in 1:dim(adjDataCombos)[1]) {
  
  samplingDate <- adjDataCombos$samplingDate[rowNum]
  sgePhase <- adjDataCombos$sgePhase[rowNum]
  
  fullData <- readRDS(file = paste0(outDir,"phase",sgePhase,"/WholePhase/sge2Behavior_shortCols_phase",sgePhase,"_adjWholePhase.RDS"))
  partialData <- readRDS(file = paste0(outDir,"phase",sgePhase,"/",samplingDate,"/sge2Behavior_shortCols_phase",sgePhase,"_adj",samplingDate,".RDS"))

  compareData <- merge(fullData,
                       partialData,
                       by = "animalID", suffixes = c(".full",".part"))
  
  avgKept <- round(mean(compareData$fractionKept.part), digits = 2)
  
  eloCorr <- round(cor.test(x = compareData$groupcent_elo.full,
                            y = compareData$groupcent_elo.part)$estimate, digits = 4)
  
  ggplot(data = compareData,
         aes(x = groupcent_elo.full,
             y = groupcent_elo.part)) +
    geom_smooth(method = "lm", formula = "y~x", se = FALSE, lwd = .5, col = "black") +
    geom_point(aes(col = group.part), size = 3) +
    labs(col = "Group") +
    ggtitle(paste0("Centered Elo: at ",samplingDate," v. Full - SGEII Phase ",sgePhase),
            subtitle = paste0(avgKept," of Phase Obs. used | R = ", eloCorr))
  
  ggsave(paste0(figDir,"/phase",sgePhase,"/",samplingDate,"/","sge2phase1_",samplingDate,"vFull_centElo_XYplot.png"),
         width = 6, height = 4)

  agrCorr <- round(cor.test(x = compareData$groupcent_agRec.full,
                            y = compareData$groupcent_agRec.part)$estimate, digits = 4)
  
  ggplot(data = compareData,
         aes(x = groupcent_agRec.full,
             y = groupcent_agRec.part)) +
    geom_smooth(method = "lm", formula = "y~x", se = FALSE, lwd = .5, col = "black") +
    geom_point(aes(col = group.part), size = 3) +
    labs(col = "Group") +
    ggtitle(paste0("Centered AgRec: at ",samplingDate," v. Full - SGEII Phase ",sgePhase),
            subtitle = paste0(avgKept," of Phase Obs. used | R = ", agrCorr))
  
  ggsave(paste0(figDir,"/phase",sgePhase,"/",samplingDate,"/","sge2phase1_",samplingDate,"vFull_centAgRec_XYplot.png"),
         width = 6, height = 4)

  grmCorr <- round(cor.test(x = compareData$groupcent_groom.full,
                            y = compareData$groupcent_groom.part)$estimate, digits = 4)
  
  ggplot(data = compareData,
         aes(x = groupcent_groom.full,
             y = groupcent_groom.part)) +
    geom_smooth(method = "lm", formula = "y~x", se = FALSE, lwd = .5, col = "black") +
    geom_point(aes(col = group.part), size = 3) +
    labs(col = "Group") +
    ggtitle(paste0("Centered Groom: at ",samplingDate," v. Full - SGEII Phase ",sgePhase),
            subtitle = paste0(avgKept," of Phase Obs. used | R = ", grmCorr))
  
    ggsave(paste0(figDir,"/phase",sgePhase,"/",samplingDate,"/","sge2phase1_",samplingDate,"vFull_centGroom_XYplot.png"),
         width = 6, height = 4)

    groupByGroup <- rbind.data.frame(groupByGroup,
                                     unique(cbind.data.frame(compareData$fractionKept.part,
                                                             compareData$group.part,
                                                             compareData$adjDate.part,
                                                             compareData$phase.part)))
}

colnames(groupByGroup) <- c("obsKept","group","sampleDate","phase")

#don't need _1 designation
groupByGroup$group <- gsub(pattern = "_1", replacement = "", x = groupByGroup$group)

#separate experiments by phase
groupByGroup$expPhase <- paste0(groupByGroup$phase,"_",groupByGroup$sampleDate)

ggplot(data = groupByGroup,
       aes(x = obsKept,
           y = expPhase)) +
  geom_violin(col = "white") +
  geom_jitter(aes(col = group), size = 3, width = 0, height = .1) +
  xlim(c(0,1))

ggsave(paste0(figDir,"/groupByGroup_observations_by_samplingpoint.png"),
         width = 6, height = 4)
```

```{r sandbox to test data}

### who was dropped from analyses for 50%?
rowNum <- 3

for (rowNum in 1:dim(dataCombos)[1]) {
  samplingDate <- dataCombos$samplingDate[rowNum]
  sgePhase <- dataCombos$sgePhase[rowNum]
  
  print(paste0("SGEII phase",sgePhase," exp:",samplingDate))
  allAnimalMeta <- readRDS(file = paste0(outDir,"phase",sgePhase,"/",samplingDate,
                                         "/sge2Behavior_phase",sgePhase,"_adj",samplingDate,"_allAnimals.RDS"))
  
  if (dim(subset(allAnimalMeta, fracTimeInGroup < .5))[1] == 0) {
    print(paste0("        No Animals Dropped for 50% rule"))
  } else {
    print("        Dropped Animals:")
    print(subset(allAnimalMeta, fracTimeInGroup < .5)$animalID)
  }
}


#group-intro order comparison for NSPF4/phase 1
allAnimalMeta <- readRDS(file = paste0(outDir,"phase",sgePhase,"/",samplingDate,
                                         "/sge2Behavior_phase",sgePhase,"_adj",samplingDate,"_allAnimals.RDS"))
sgePhase <- 1
samplingDate <- "Vax"
gcAnimalMeta <- readRDS(file = paste0(outDir,"phase",sgePhase,"/",samplingDate,
                                         "/sge2Behavior_phase",sgePhase,"_adj",samplingDate,".RDS"))

ggplot(data = gcAnimalMeta,
       aes(x = intro.no,
           y = groupcent_elo,
           col = group.agg)) +
  geom_point() +
  geom_smooth(method = "lm", formula = "y~x", se = FALSE)

subset(gcAnimalMeta, group.agg == "NSPF4_1")

sgePhase <- 1
samplingDate <- "Vax"
gcAnimalMeta <- readRDS(file = paste0(outDir,"phase",sgePhase,"/",samplingDate,
                                         "/sge2Behavior_phase",sgePhase,"_adj",samplingDate,".RDS"))

subset(gcAnimalMeta, group.agg == "NSPF5_1")$groupcent_agRec
```

```{r combine Phase 1 and Phase 2}
### use vaccine date in phase 2
### only calculate for animals that were 
p1All <- readRDS(paste0(outDir,"phase1/WholePhase/sge2Behavior_phase1_adjWholePhase.RDS"))
p2Vax <- readRDS(paste0(outDir,"phase2/Vax/sge2Behavior_phase2_adjVax.RDS"))

ID <- p2Vax$ID[p2Vax$ID %in% p1All$ID]

## data
animalID <- vector()
groupP1 <- vector()
groupP2 <- vector()
ordRankP1 <- vector()
ordRankP2 <- vector()
totObs <- vector()
p1Obs <- vector()
p2Obs <- vector()
totAggRec <- vector()
totGroomMin <- vector()
totGroomMinGive <- vector()
totGroomMinReceive <- vector()
rawAgRecP1 <- vector()
rawAgRecP2 <- vector()
rawEloP1 <- vector()
rawEloP2 <- vector()
rawGroomP1 <- vector()
rawGroomP2 <- vector()
gcAgRecP1 <- vector()
gcAgRecP2 <- vector()
gcEloP1 <- vector()
gcEloP2 <- vector()
gcGroomP1 <- vector()
gcGroomP2 <- vector()

for (i in ID) {
  p1sub <- subset(p1All, ID == i)
  p2sub <- subset(p2Vax, ID == i)
  
  animalID <- c(animalID, p1sub$animalID)
  groupP1 <- c(groupP1, p1sub$group.gc)
  groupP2 <- c(groupP2, p2sub$group.gc)
  ordRankP1 <- c(ordRankP1, p1sub$ordinal.rank)
  ordRankP2 <- c(ordRankP2, p2sub$ordinal.rank)
  totObs <- c(totObs, p1sub$no.obs + p2sub$no.obs)
  p1Obs <- c(p1Obs, p1sub$no.obs)
  p2Obs <- c(p2Obs, p2sub$no.obs)
  totAggRec <- c(totAggRec, p1sub$agg.received + p2sub$agg.received)
  totGroomMin <- c(totGroomMin, p1sub$min + p2sub$min)
  totGroomMinGive <- c(totGroomMinGive, p1sub$min.give + p2sub$min.give)
  totGroomMinReceive <- c(totGroomMinReceive, p1sub$min.receive + p2sub$min.receive)
  rawAgRecP1 <- c(rawAgRecP1,p1sub$rawAggRecRate)
  rawAgRecP2 <- c(rawAgRecP2,p2sub$rawAggRecRate)
  rawEloP1   <- c(rawEloP1,p1sub$calcElo)
  rawEloP2   <- c(rawEloP2,p2sub$calcElo)
  rawGroomP1 <- c(rawGroomP1,p1sub$rawGroomRate)
  rawGroomP2 <- c(rawGroomP2,p2sub$rawGroomRate)
  gcAgRecP1  <- c(gcAgRecP1,p1sub$groupcent_agRec)
  gcAgRecP2  <- c(gcAgRecP2,p2sub$groupcent_agRec)
  gcEloP1    <- c(gcEloP1,p1sub$groupcent_elo)
  gcEloP2    <- c(gcEloP2,p2sub$groupcent_elo)
  gcGroomP1  <- c(gcGroomP1,p1sub$groupcent_groom)
  gcGroomP2  <- c(gcGroomP2,p2sub$groupcent_groom)
}

comboP1P2 <- cbind.data.frame(ID,
                               animalID,
                               groupP1,
                               groupP2,
                               ordRankP1,
                               ordRankP2,
                               totObs,
                              p1Obs,
                              p2Obs,
                               totAggRec,
                               totGroomMin,
                               totGroomMinGive,
                               totGroomMinReceive,
                              rawAgRecP1,
                              rawAgRecP2,
                              rawEloP1,
                              rawEloP2,
                              rawGroomP1,
                              rawGroomP2,
                              gcAgRecP1,
                              gcAgRecP2,
                              gcEloP1,
                              gcEloP2,
                              gcGroomP1,
                              gcGroomP2)

comboP1P2$rawCombinedGroomRate <- 2 * (comboP1P2$totGroomMin / comboP1P2$totObs)
comboP1P2$rawCombinedAggRecRate <- 2 * (comboP1P2$totAggRec / comboP1P2$totObs)

comboP1P2$percentP1Obs <- comboP1P2$p1Obs / comboP1P2$totObs

comboP1P2$gcCombinedAggRecRate <- comboP1P2$gcAgRecP1 * comboP1P2$percentP1Obs + comboP1P2$gcAgRecP2 * (1 - comboP1P2$percentP1Obs)
comboP1P2$gcCombinedGroomRate <- comboP1P2$gcGroomP1 * comboP1P2$percentP1Obs + comboP1P2$gcGroomP2 * (1 - comboP1P2$percentP1Obs)
comboP1P2$gcCombinedElo <- comboP1P2$gcEloP1 * comboP1P2$percentP1Obs + comboP1P2$gcEloP2 * (1 - comboP1P2$percentP1Obs)

saveRDS(object = comboP1P2,
        file = paste0(outDir,"/","sge2Behavior_phase1and2_combinedBehaviors.RDS"))

write.table(x = comboP1P2,
              file = paste0(outDir,"/","sge2Behavior_phase1and2_combinedBehaviors.txt"),
              quote = FALSE, 
              sep = ",")

ggplot(data = p1All,
       aes(x = rawAggRecRate,
           y = groupcent_agRec)) +
  geom_point()

ggplot(data = p2Vax,
       aes(x = rawAggRecRate,
           y = groupcent_agRec,
           col = group.agg)) +
  geom_point()

ggplot() +
  geom_point(aes(x = comboP1P2$rawCombinedGroomRate,
           y = comboP1P2$rawGroomP1 * comboP1P2$percentP1Obs + comboP1P2$rawGroomP2 * (1 - comboP1P2$percentP1Obs))) +
  xlab("groom calculated from total events / total obs (p1 + p2)") +
  ylab("groom calculated from weighted average of p1 and p2")

ggplot() +
  geom_point(aes(x = comboP1P2$rawCombinedAggRecRate,
           y = comboP1P2$rawAgRecP1 * comboP1P2$percentP1Obs + comboP1P2$rawAgRecP2 * (1 - comboP1P2$percentP1Obs))) +
  xlab("agRec calculated from total events / total obs (p1 + p2)") +
  ylab("agRec calculated from weighted average of p1 and p2")
```


Updates -- Sept 2025
-What were the dates used to calculate elo?
```{r}
#phase 1
#start date
sge2p1start <- sge2p1dates %>%
  dplyr::filter(event == "in") %>%
  dplyr::group_by(group) %>%
  dplyr::summarize(start = min(date))

#vax date
sge2p1vax <- sge2p1dates %>%
  dplyr::select(-animal) %>%
  dplyr::filter(event == "vaccine") %>%
  dplyr::arrange(group) %>%
  dplyr::distinct()

sge2p1start %>%
  dplyr::left_join(sge2p1vax, by = "group") %>%
  dplyr::select(-event) %>%
  dplyr::rename(end = date)

#phase 2
#start date
sge2p2start <- sge2p2dates %>%
  dplyr::filter(event == "in") %>%
  dplyr::group_by(group) %>%
  dplyr::summarize(start = min(date))

#vax date
sge2p2vax <- sge2p2dates %>%
  dplyr::select(-animal) %>%
  dplyr::filter(event == "vaccine") %>%
  dplyr::arrange(group) %>%
  dplyr::distinct()

sge2p2start %>%
  dplyr::left_join(sge2p2vax, by = "group") %>%
  dplyr::select(-event) %>%
  dplyr::rename(end = date)

```

- rank hierarchies were linear and stable: 
correlation elo after group formation vs end of vaccine experiment (for phases 1 and 2)

```{r}



```


- grooming interactions were more frequent between adjacently ranked animals: 
I found this in one of the papers but not sure how to calculate: "we found that females who were adjacent in rank were more likely to groom together. This pattern was detectable whether we tested for a binary pattern (groomed at all versus never groomed: βrank_disparity = −1.53,  Z = −4.94,  N = 360 dyads, P = 9.38 × 10−7), or whether we investigated the proportion of total grooming time that a female invested in a grooming partner, pGroom total, in those dyads that groomed at least once (βrank_disparity = −0.43, t310.0 = −7.06, N = 318 dyads, P = 1.09 × 10−11; Fig. 3)". 

```{r}

```

- grooming was biased towards grooming up the status hierarchy:  
subset 2nd, 3rd and 4th rank females; calculate mean rate of grooming higher-ranking females vs mean rate of grooming lower-ranking females; paired t test

```{r}

```




